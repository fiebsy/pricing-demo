{"version":3,"file":"use-table-with-async.js","sourceRoot":"/","sources":["other-repos/demo-repo/src/components/ui/prod/data/sticky-data-table/hooks/data-adapters/use-table-with-async.ts"],"names":[],"mappings":"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","sourcesContent":["'use client'\n\n/**\n * useTableWithAsync - Generic Async Data Adapter\n *\n * For use with any async data source (fetch, axios, custom APIs).\n * Provides automatic skeleton management for tables without GraphQL.\n *\n * @module hooks/data-adapters/use-table-with-async\n *\n * @example Basic Usage with fetch\n * ```tsx\n * const { tableProps, fetchData } = useTableWithAsync<User>()\n *\n * useEffect(() => {\n *   fetchData(async () => {\n *     const response = await fetch('/api/users')\n *     return response.json()\n *   })\n * }, [])\n *\n * <StickyDataTable {...tableProps} columns={columns} />\n * ```\n *\n * @example With Filters\n * ```tsx\n * const { tableProps, fetchData, applyFilters } = useTableWithAsync<User>()\n *\n * const handleFilterChange = (newFilters) => {\n *   applyFilters(async () => {\n *     const response = await fetch(`/api/users?status=${newFilters.status}`)\n *     return response.json()\n *   })\n * }\n * ```\n *\n * @example With Pagination\n * ```tsx\n * const { tableProps, infiniteScrollProps, loadMore, setHasNextPage } = useTableWithAsync<User>()\n *\n * // After initial fetch\n * setHasNextPage(response.hasMore)\n *\n * // Configure loadMore\n * loadMore.setHandler(async () => {\n *   const response = await fetch(`/api/users?page=${nextPage}`)\n *   const newData = await response.json()\n *   setHasNextPage(response.hasMore)\n *   return newData // Will be appended to existing data\n * })\n * ```\n */\n\nimport { useCallback, useRef, useState } from 'react'\nimport type { InfiniteScrollConfig } from '../../types'\nimport { useTableLoadingState, type TableLoadingStateOptions } from './use-table-loading-state'\n\n// ============================================================================\n// Types\n// ============================================================================\n\nexport interface UseTableWithAsyncOptions<TData> extends TableLoadingStateOptions {\n  /**\n   * Initial data (optional)\n   * @default []\n   */\n  initialData?: TData[]\n\n  /**\n   * Number of skeleton rows during load-more\n   * @default 5\n   */\n  skeletonRowCount?: number\n\n  /**\n   * Threshold in pixels from bottom to trigger load more\n   * @default 200\n   */\n  loadMoreThreshold?: number\n\n  /**\n   * Called when any fetch operation fails\n   */\n  onError?: (error: unknown) => void\n\n  /**\n   * Automatically clear tableProps.data during filter/initial loading\n   * to trigger skeleton display. When true (default), consumers just\n   * spread tableProps and skeletons work automatically.\n   *\n   * Set to false if you need to keep stale data visible during loading.\n   * @default true\n   */\n  clearDataOnLoading?: boolean\n}\n\nexport interface UseTableWithAsyncReturn<TData> {\n  /**\n   * Props to spread on StickyDataTable.\n   * data is automatically cleared during loading when clearDataOnLoading=true (default).\n   */\n  tableProps: {\n    data: TData[]\n    isLoading: boolean\n  }\n\n  /**\n   * Original data array (not cleared during loading).\n   * Use this for counts, exports, or when you need access to data during loading.\n   */\n  rawData: TData[]\n\n  /**\n   * Props for infinite scroll (only if loadMore is configured)\n   */\n  infiniteScrollProps?: InfiniteScrollConfig\n\n  /**\n   * Current data array (alias for rawData for backwards compatibility)\n   */\n  data: TData[]\n\n  /**\n   * Set data directly (for external state management)\n   */\n  setData: React.Dispatch<React.SetStateAction<TData[]>>\n\n  /**\n   * Fetch initial data with auto-skeleton\n   */\n  fetchData: (fetcher: () => Promise<TData[]>) => Promise<void>\n\n  /**\n   * Fetch with filter change skeleton\n   */\n  applyFilters: (fetcher: () => Promise<TData[]>) => Promise<void>\n\n  /**\n   * Refetch data with auto-skeleton\n   */\n  refetch: (fetcher: () => Promise<TData[]>) => Promise<void>\n\n  /**\n   * Load more data (appends to existing)\n   */\n  loadMore: {\n    /**\n     * Set the load more handler\n     */\n    setHandler: (handler: () => Promise<TData[]>) => void\n    /**\n     * Trigger load more manually\n     */\n    trigger: () => Promise<void>\n  }\n\n  /**\n   * Set whether more pages are available\n   */\n  setHasNextPage: (hasNext: boolean) => void\n\n  /**\n   * Loading states for custom UI\n   */\n  loadingStates: {\n    isLoading: boolean\n    isInitialLoading: boolean\n    isFiltering: boolean\n    isRefetching: boolean\n    isLoadingMore: boolean\n    hasInitialData: boolean\n  }\n\n  /**\n   * Clear all data and reset state\n   */\n  reset: () => void\n}\n\n// ============================================================================\n// Hook Implementation\n// ============================================================================\n\nexport function useTableWithAsync<TData>({\n  initialData = [],\n  skeletonRowCount = 5,\n  loadMoreThreshold = 200,\n  minimumLoadingDuration = 300,\n  showSkeletonOnMount = true,\n  loadingDebounce = 50,\n  onError,\n  clearDataOnLoading = true,\n}: UseTableWithAsyncOptions<TData> = {}): UseTableWithAsyncReturn<TData> {\n  // Data state\n  const [data, setData] = useState<TData[]>(initialData)\n  const [hasNextPage, setHasNextPage] = useState(false)\n  const [isLoadingMore, setIsLoadingMore] = useState(false)\n\n  // Load more handler ref\n  const loadMoreHandlerRef = useRef<(() => Promise<TData[]>) | null>(null)\n\n  // Core loading state management\n  const { state, actions } = useTableLoadingState({\n    minimumLoadingDuration,\n    showSkeletonOnMount: showSkeletonOnMount && initialData.length === 0,\n    loadingDebounce,\n  })\n\n  // -------------------------------------------------------------------------\n  // Fetch initial data\n  // -------------------------------------------------------------------------\n  const fetchData = useCallback(\n    async (fetcher: () => Promise<TData[]>) => {\n      try {\n        const result = await actions.withLoading('initial', fetcher)\n        setData(result)\n        if (result.length > 0) {\n          actions.markInitialDataLoaded()\n        }\n      } catch (error) {\n        console.error('Failed to fetch data:', error)\n        onError?.(error)\n        throw error\n      }\n    },\n    [actions, onError]\n  )\n\n  // -------------------------------------------------------------------------\n  // Apply filters (replaces data)\n  // -------------------------------------------------------------------------\n  const applyFilters = useCallback(\n    async (fetcher: () => Promise<TData[]>) => {\n      try {\n        const result = await actions.withLoading('filter', fetcher)\n        setData(result)\n      } catch (error) {\n        console.error('Failed to apply filters:', error)\n        onError?.(error)\n        throw error\n      }\n    },\n    [actions, onError]\n  )\n\n  // -------------------------------------------------------------------------\n  // Refetch data\n  // -------------------------------------------------------------------------\n  const refetch = useCallback(\n    async (fetcher: () => Promise<TData[]>) => {\n      try {\n        const result = await actions.withLoading('refetch', fetcher)\n        setData(result)\n      } catch (error) {\n        console.error('Failed to refetch:', error)\n        onError?.(error)\n        throw error\n      }\n    },\n    [actions, onError]\n  )\n\n  // -------------------------------------------------------------------------\n  // Load more handler\n  // -------------------------------------------------------------------------\n  const handleLoadMore = useCallback(async () => {\n    if (!loadMoreHandlerRef.current || isLoadingMore) return\n\n    setIsLoadingMore(true)\n    const startTime = Date.now()\n\n    try {\n      const newData = await loadMoreHandlerRef.current()\n      setData((prev) => [...prev, ...newData])\n    } catch (error) {\n      console.error('Failed to load more:', error)\n      onError?.(error)\n    } finally {\n      // Ensure minimum display time for skeleton\n      const elapsed = Date.now() - startTime\n      const remaining = Math.max(0, minimumLoadingDuration - elapsed)\n\n      if (remaining > 0) {\n        setTimeout(() => setIsLoadingMore(false), remaining)\n      } else {\n        setIsLoadingMore(false)\n      }\n    }\n  }, [isLoadingMore, minimumLoadingDuration, onError])\n\n  const setLoadMoreHandler = useCallback((handler: () => Promise<TData[]>) => {\n    loadMoreHandlerRef.current = handler\n  }, [])\n\n  // -------------------------------------------------------------------------\n  // Reset state\n  // -------------------------------------------------------------------------\n  const reset = useCallback(() => {\n    setData(initialData)\n    setHasNextPage(false)\n    setIsLoadingMore(false)\n    loadMoreHandlerRef.current = null\n    actions.reset()\n  }, [initialData, actions])\n\n  // -------------------------------------------------------------------------\n  // Build infinite scroll config\n  // -------------------------------------------------------------------------\n  const infiniteScrollProps: InfiniteScrollConfig | undefined =\n    loadMoreHandlerRef.current\n      ? {\n          hasNextPage,\n          isLoadingMore,\n          onLoadMore: handleLoadMore,\n          skeletonRowCount,\n          threshold: loadMoreThreshold,\n        }\n      : undefined\n\n  // -------------------------------------------------------------------------\n  // Compute final loading state\n  // -------------------------------------------------------------------------\n  const shouldShowSkeleton = state.isLoading && (\n    !state.hasInitialData ||\n    state.isFiltering ||\n    (state.isRefetching && data.length === 0)\n  )\n\n  // When clearDataOnLoading is true (default), automatically clear data\n  // during loading so skeleton rows appear. This makes the pattern foolproof.\n  const effectiveData = clearDataOnLoading && shouldShowSkeleton ? [] : data\n\n  return {\n    tableProps: {\n      data: effectiveData,\n      isLoading: shouldShowSkeleton,\n    },\n    // Expose original data for counts, exports, etc.\n    rawData: data,\n    infiniteScrollProps,\n    data, // Backwards compatibility alias\n    setData,\n    fetchData,\n    applyFilters,\n    refetch,\n    loadMore: {\n      setHandler: setLoadMoreHandler,\n      trigger: handleLoadMore,\n    },\n    setHasNextPage,\n    loadingStates: {\n      isLoading: state.isLoading,\n      isInitialLoading: !state.hasInitialData && state.isLoading,\n      isFiltering: state.isFiltering,\n      isRefetching: state.isRefetching,\n      isLoadingMore,\n      hasInitialData: state.hasInitialData,\n    },\n    reset,\n  }\n}\n"]}