{"version":3,"file":"use-table-loading-state.js","sourceRoot":"/","sources":["other-repos/demo-repo/src/components/ui/prod/data/sticky-data-table/hooks/data-adapters/use-table-loading-state.ts"],"names":[],"mappings":"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","sourcesContent":["'use client'\n\n/**\n * useTableLoadingState - Core Loading State Management\n *\n * Framework-agnostic hook that manages table loading states for:\n * - Initial data load\n * - Filter/search changes\n * - Refetch operations\n * - Infinite scroll (via integration with useInfiniteScroll)\n *\n * This is the foundation hook used by all data adapters.\n *\n * @module hooks/data-adapters/use-table-loading-state\n */\n\nimport { useCallback, useEffect, useRef, useState } from 'react'\n\n// ============================================================================\n// Types\n// ============================================================================\n\nexport interface TableLoadingStateOptions {\n  /**\n   * Minimum time in ms to show skeleton (prevents flash on fast loads)\n   * @default 300\n   */\n  minimumLoadingDuration?: number\n\n  /**\n   * Whether to show skeleton on initial mount\n   * @default true\n   */\n  showSkeletonOnMount?: boolean\n\n  /**\n   * Debounce time in ms before showing loading state\n   * Prevents skeleton flash for very fast operations\n   * @default 50\n   */\n  loadingDebounce?: number\n}\n\nexport interface TableLoadingState {\n  /**\n   * Whether table should show skeleton (use this for isLoading prop)\n   */\n  isLoading: boolean\n\n  /**\n   * Whether initial data has been loaded at least once\n   */\n  hasInitialData: boolean\n\n  /**\n   * Whether a filter/search change is in progress\n   */\n  isFiltering: boolean\n\n  /**\n   * Whether a refetch operation is in progress\n   */\n  isRefetching: boolean\n}\n\nexport interface TableLoadingActions {\n  /**\n   * Call when starting any loading operation\n   * Returns a function to call when loading completes\n   */\n  startLoading: (type: 'initial' | 'filter' | 'refetch') => () => void\n\n  /**\n   * Wrap an async operation with automatic loading state management\n   */\n  withLoading: <T>(\n    type: 'initial' | 'filter' | 'refetch',\n    operation: () => Promise<T>\n  ) => Promise<T>\n\n  /**\n   * Mark initial data as loaded (call after first successful fetch)\n   */\n  markInitialDataLoaded: () => void\n\n  /**\n   * Reset all loading states (useful for unmount/cleanup)\n   */\n  reset: () => void\n}\n\nexport interface UseTableLoadingStateReturn {\n  state: TableLoadingState\n  actions: TableLoadingActions\n}\n\n// ============================================================================\n// Hook Implementation\n// ============================================================================\n\nexport function useTableLoadingState(\n  options: TableLoadingStateOptions = {}\n): UseTableLoadingStateReturn {\n  const {\n    minimumLoadingDuration = 300,\n    showSkeletonOnMount = true,\n    loadingDebounce = 50,\n  } = options\n\n  // Core state\n  const [isInitialLoading, setIsInitialLoading] = useState(showSkeletonOnMount)\n  const [isFiltering, setIsFiltering] = useState(false)\n  const [isRefetching, setIsRefetching] = useState(false)\n  const [hasInitialData, setHasInitialData] = useState(false)\n\n  // Track active loading operations\n  const loadingStartTimeRef = useRef<number | null>(null)\n  const debounceTimerRef = useRef<NodeJS.Timeout | null>(null)\n  const activeLoadingTypeRef = useRef<'initial' | 'filter' | 'refetch' | null>(null)\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      if (debounceTimerRef.current) {\n        clearTimeout(debounceTimerRef.current)\n      }\n    }\n  }, [])\n\n  /**\n   * Set loading state based on type\n   */\n  const setLoadingState = useCallback(\n    (type: 'initial' | 'filter' | 'refetch', value: boolean) => {\n      switch (type) {\n        case 'initial':\n          setIsInitialLoading(value)\n          break\n        case 'filter':\n          setIsFiltering(value)\n          break\n        case 'refetch':\n          setIsRefetching(value)\n          break\n      }\n    },\n    []\n  )\n\n  /**\n   * Start a loading operation\n   * Returns a function to call when complete\n   */\n  const startLoading = useCallback(\n    (type: 'initial' | 'filter' | 'refetch') => {\n      // Clear any pending debounce\n      if (debounceTimerRef.current) {\n        clearTimeout(debounceTimerRef.current)\n      }\n\n      // Track when loading started\n      loadingStartTimeRef.current = Date.now()\n      activeLoadingTypeRef.current = type\n\n      // Debounce the loading state to prevent flash\n      debounceTimerRef.current = setTimeout(() => {\n        setLoadingState(type, true)\n      }, loadingDebounce)\n\n      // Return completion function\n      return () => {\n        const startTime = loadingStartTimeRef.current\n        const elapsed = startTime ? Date.now() - startTime : 0\n        const remaining = Math.max(0, minimumLoadingDuration - elapsed)\n\n        // Clear debounce timer if still pending\n        if (debounceTimerRef.current) {\n          clearTimeout(debounceTimerRef.current)\n          debounceTimerRef.current = null\n        }\n\n        // Ensure minimum display duration\n        if (remaining > 0) {\n          setTimeout(() => {\n            setLoadingState(type, false)\n            activeLoadingTypeRef.current = null\n          }, remaining)\n        } else {\n          setLoadingState(type, false)\n          activeLoadingTypeRef.current = null\n        }\n\n        loadingStartTimeRef.current = null\n      }\n    },\n    [loadingDebounce, minimumLoadingDuration, setLoadingState]\n  )\n\n  /**\n   * Wrap an async operation with loading state management\n   */\n  const withLoading = useCallback(\n    async <T,>(\n      type: 'initial' | 'filter' | 'refetch',\n      operation: () => Promise<T>\n    ): Promise<T> => {\n      const complete = startLoading(type)\n      try {\n        const result = await operation()\n        return result\n      } finally {\n        complete()\n      }\n    },\n    [startLoading]\n  )\n\n  /**\n   * Mark that initial data has been loaded\n   */\n  const markInitialDataLoaded = useCallback(() => {\n    setHasInitialData(true)\n    setIsInitialLoading(false)\n  }, [])\n\n  /**\n   * Reset all states\n   */\n  const reset = useCallback(() => {\n    setIsInitialLoading(showSkeletonOnMount)\n    setIsFiltering(false)\n    setIsRefetching(false)\n    setHasInitialData(false)\n    loadingStartTimeRef.current = null\n    activeLoadingTypeRef.current = null\n    if (debounceTimerRef.current) {\n      clearTimeout(debounceTimerRef.current)\n      debounceTimerRef.current = null\n    }\n  }, [showSkeletonOnMount])\n\n  // Compute aggregate loading state\n  const isLoading = isInitialLoading || isFiltering || isRefetching\n\n  return {\n    state: {\n      isLoading,\n      hasInitialData,\n      isFiltering,\n      isRefetching,\n    },\n    actions: {\n      startLoading,\n      withLoading,\n      markInitialDataLoaded,\n      reset,\n    },\n  }\n}\n"]}