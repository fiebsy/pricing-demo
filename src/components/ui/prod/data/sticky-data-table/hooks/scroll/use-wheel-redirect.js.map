{"version":3,"file":"use-wheel-redirect.js","sourceRoot":"/","sources":["other-repos/demo-repo/src/components/ui/prod/data/sticky-data-table/hooks/scroll/use-wheel-redirect.ts"],"names":[],"mappings":"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","sourcesContent":["'use client'\n\n/**\n * StickyDataTable V2 - Wheel Scroll Containment Hook\n *\n * Manages scroll behavior for horizontal-scroll containers to prevent\n * scroll trapping while maintaining natural UX.\n *\n * DESIGN PRINCIPLES:\n * 1. Vertical scroll ALWAYS passes through to the page (never trapped)\n * 2. Horizontal scroll is contained ONLY when the table can scroll in that direction\n * 3. At horizontal boundaries, scroll escapes to parent (no trapping)\n * 4. Momentum scrolling and trackpad gestures work naturally\n *\n * @module hooks/use-wheel-redirect\n */\n\nimport { useEffect, useRef, useCallback } from 'react'\n\ninterface UseWheelRedirectProps {\n  /** Reference to the scrollable body element */\n  bodyRef: React.RefObject<HTMLDivElement | null>\n  /** Enable/disable scroll management */\n  enabled?: boolean\n}\n\n/** Threshold in pixels to consider \"at boundary\" (accounts for sub-pixel rounding) */\nconst BOUNDARY_THRESHOLD = 1\n\n/** Minimum delta to consider intentional scroll vs noise */\nconst MIN_SCROLL_DELTA = 1\n\n/**\n * Determines if the container can scroll in the given horizontal direction\n */\nfunction canScrollInDirection(\n  element: HTMLElement,\n  deltaX: number\n): boolean {\n  const { scrollLeft, scrollWidth, clientWidth } = element\n  const hasOverflow = scrollWidth > clientWidth\n\n  if (!hasOverflow) return false\n\n  // Scrolling left (deltaX < 0): can scroll if not at left edge\n  if (deltaX < 0) {\n    return scrollLeft > BOUNDARY_THRESHOLD\n  }\n\n  // Scrolling right (deltaX > 0): can scroll if not at right edge\n  if (deltaX > 0) {\n    return scrollLeft + clientWidth < scrollWidth - BOUNDARY_THRESHOLD\n  }\n\n  return false\n}\n\n/**\n * Hook for intelligent scroll containment\n *\n * This hook implements a \"pass-through by default\" strategy:\n * - Vertical scroll: NEVER intercepted, always propagates to page\n * - Horizontal scroll: Only contained when table has room to scroll\n * - Boundary behavior: Events escape at scroll edges\n *\n * This approach is more robust than redirect-based solutions because:\n * - Uses native browser scrolling (respects momentum, accessibility)\n * - No manual window.scrollBy() calls that can fail\n * - Works in nested scroll contexts (modals, iframes)\n * - Supports trackpad gestures naturally\n *\n * @example\n * ```tsx\n * useWheelRedirect({ bodyRef: scrollContainerRef })\n * ```\n */\nexport function useWheelRedirect({\n  bodyRef,\n  enabled = true,\n}: UseWheelRedirectProps): void {\n  // Track if we're in the middle of a horizontal scroll gesture\n  // This helps with diagonal scrolling where we want consistency\n  const isHorizontalGestureRef = useRef(false)\n  const gestureTimeoutRef = useRef<ReturnType<typeof setTimeout> | undefined>(undefined)\n\n  const resetGesture = useCallback(() => {\n    isHorizontalGestureRef.current = false\n  }, [])\n\n  useEffect(() => {\n    if (!enabled) return\n\n    const body = bodyRef.current\n    if (!body) return\n\n    const handleWheel = (e: WheelEvent) => {\n      const absX = Math.abs(e.deltaX)\n      const absY = Math.abs(e.deltaY)\n\n      // Ignore negligible scroll events (noise)\n      if (absX < MIN_SCROLL_DELTA && absY < MIN_SCROLL_DELTA) {\n        return\n      }\n\n      // Determine scroll intent\n      const isVerticalDominant = absY > absX\n      const isHorizontalDominant = absX > absY\n      const isDiagonal = absX > MIN_SCROLL_DELTA && absY > MIN_SCROLL_DELTA\n\n      // VERTICAL SCROLL: Always pass through\n      // The body has overflow-y: hidden, so it can't scroll vertically.\n      // We do NOTHING here - let the event propagate naturally to the page.\n      if (isVerticalDominant && !isDiagonal) {\n        // Clear any horizontal gesture tracking\n        isHorizontalGestureRef.current = false\n        return // Let event propagate naturally\n      }\n\n      // HORIZONTAL SCROLL: Contain only when table can scroll\n      if (isHorizontalDominant || (isDiagonal && isHorizontalGestureRef.current)) {\n        const canScroll = canScrollInDirection(body, e.deltaX)\n\n        if (canScroll) {\n          // Table can scroll in this direction - contain the scroll\n          // Don't preventDefault - let the natural scroll happen on the element\n          // Just stop propagation to prevent parent horizontal scroll\n          e.stopPropagation()\n\n          // Track that we're in a horizontal gesture\n          isHorizontalGestureRef.current = true\n\n          // Reset gesture tracking after inactivity\n          if (gestureTimeoutRef.current) {\n            clearTimeout(gestureTimeoutRef.current)\n          }\n          gestureTimeoutRef.current = setTimeout(resetGesture, 150)\n        }\n        // If can't scroll (at boundary), do nothing - event propagates to parent\n        return\n      }\n\n      // DIAGONAL SCROLL (not in horizontal gesture): Favor vertical\n      // Let vertical component pass through, horizontal will be handled by element\n      if (isDiagonal) {\n        // Don't intercept - browser handles both components appropriately\n        return\n      }\n    }\n\n    // Use passive: true for better performance\n    // We're not calling preventDefault(), so passive is safe\n    body.addEventListener('wheel', handleWheel, { passive: true })\n\n    return () => {\n      body.removeEventListener('wheel', handleWheel)\n      if (gestureTimeoutRef.current) {\n        clearTimeout(gestureTimeoutRef.current)\n      }\n    }\n  }, [bodyRef, enabled, resetGesture])\n}\n\n\n"]}