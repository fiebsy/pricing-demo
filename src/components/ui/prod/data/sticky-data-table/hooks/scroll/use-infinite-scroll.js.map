{"version":3,"file":"use-infinite-scroll.js","sourceRoot":"/","sources":["other-repos/demo-repo/src/components/ui/prod/data/sticky-data-table/hooks/scroll/use-infinite-scroll.ts"],"names":[],"mappings":";AAAA,YAAY,CAAA;;;AAEZ;;;;;;;;;;;;;;;;;;;;;;GAsBG;AAEH,iCAA6C;AA8D7C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA8BG;AACH,SAAgB,iBAAiB,CAAC,EAChC,WAAW,EACX,QAAQ,EACR,gBAAgB,GAAG,CAAC,EACpB,SAAS,GAAG,GAAG,EACf,YAAY,GAAG,GAAG,EAClB,OAAO,GACkB;IACzB,MAAM,CAAC,aAAa,EAAE,gBAAgB,CAAC,GAAG,IAAA,gBAAQ,EAAC,KAAK,CAAC,CAAA;IAEzD,MAAM,cAAc,GAAG,IAAA,mBAAW,EAAC,KAAK,IAAI,EAAE;QAC5C,uCAAuC;QACvC,IAAI,aAAa;YAAE,OAAM;QAEzB,gBAAgB,CAAC,IAAI,CAAC,CAAA;QACtB,IAAI,CAAC;YACH,6CAA6C;YAC7C,sDAAsD;YACtD,MAAM,WAAW,GAAG,OAAO,CAAC,OAAO,CAAC,QAAQ,EAAE,CAAC,CAAA;YAC/C,MAAM,YAAY,GAAG,YAAY,GAAG,CAAC;gBACnC,CAAC,CAAC,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,EAAE,CAAC,UAAU,CAAC,OAAO,EAAE,YAAY,CAAC,CAAC;gBAC7D,CAAC,CAAC,OAAO,CAAC,OAAO,EAAE,CAAA;YAErB,4BAA4B;YAC5B,MAAM,OAAO,CAAC,GAAG,CAAC,CAAC,WAAW,EAAE,YAAY,CAAC,CAAC,CAAA;QAChD,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,OAAO,CAAC,KAAK,CAAC,sBAAsB,EAAE,KAAK,CAAC,CAAA;YAC5C,OAAO,EAAE,CAAC,KAAK,CAAC,CAAA;QAClB,CAAC;gBAAS,CAAC;YACT,gBAAgB,CAAC,KAAK,CAAC,CAAA;QACzB,CAAC;IACH,CAAC,EAAE,CAAC,aAAa,EAAE,QAAQ,EAAE,YAAY,EAAE,OAAO,CAAC,CAAC,CAAA;IAEpD,MAAM,mBAAmB,GAAyB;QAChD,WAAW;QACX,aAAa;QACb,UAAU,EAAE,cAAc;QAC1B,gBAAgB;QAChB,SAAS;KACV,CAAA;IAED,OAAO;QACL,mBAAmB;QACnB,aAAa;QACb,eAAe,EAAE,cAAc;KAChC,CAAA;AACH,CAAC;AA9CD,8CA8CC","sourcesContent":["'use client'\n\n/**\n * useInfiniteScroll Hook\n *\n * Universal hook for infinite scroll with automatic skeleton delay.\n * Handles loading state management and ensures skeleton is visible for a minimum duration.\n *\n * @module hooks/use-infinite-scroll\n *\n * @example\n * ```tsx\n * const { infiniteScrollProps, isLoadingMore } = useInfiniteScroll({\n *   hasNextPage,\n *   loadMore,\n *   skeletonRowCount: 10,\n *   minimumDelay: 250, // Default\n * })\n *\n * <StickyDataTable\n *   data={items}\n *   infiniteScroll={infiniteScrollProps}\n * />\n * ```\n */\n\nimport { useCallback, useState } from 'react'\nimport type { InfiniteScrollConfig } from '../../types'\n\n/**\n * Configuration options for useInfiniteScroll\n */\nexport interface UseInfiniteScrollOptions {\n  /**\n   * Whether more data is available to load\n   */\n  hasNextPage: boolean\n\n  /**\n   * Function to load more data\n   * Should return a Promise that resolves when data is loaded\n   */\n  loadMore: () => Promise<void> | void\n\n  /**\n   * Number of skeleton rows to show while loading\n   * @default 5\n   */\n  skeletonRowCount?: number\n\n  /**\n   * Distance in pixels from bottom to trigger loading\n   * @default 200\n   */\n  threshold?: number\n\n  /**\n   * Minimum time in ms to show skeleton (prevents flash on fast loads)\n   * @default 250\n   */\n  minimumDelay?: number\n\n  /**\n   * Callback when loading fails\n   */\n  onError?: (error: unknown) => void\n}\n\n/**\n * Return value from useInfiniteScroll\n */\nexport interface UseInfiniteScrollReturn {\n  /**\n   * Props to spread on StickyDataTable's infiniteScroll prop\n   */\n  infiniteScrollProps: InfiniteScrollConfig\n\n  /**\n   * Whether data is currently being loaded\n   */\n  isLoadingMore: boolean\n\n  /**\n   * Manually trigger load more (useful for \"Load More\" buttons)\n   */\n  triggerLoadMore: () => Promise<void>\n}\n\n/**\n * Universal infinite scroll hook with automatic skeleton delay\n *\n * This hook abstracts the loading state management and delay logic,\n * making infinite scroll consistent across all tables.\n *\n * @example Basic usage\n * ```tsx\n * const { infiniteScrollProps } = useInfiniteScroll({\n *   hasNextPage,\n *   loadMore: fetchNextPage,\n * })\n *\n * <StickyDataTable\n *   data={items}\n *   columns={columns}\n *   infiniteScroll={infiniteScrollProps}\n * />\n * ```\n *\n * @example With custom delay and error handling\n * ```tsx\n * const { infiniteScrollProps, isLoadingMore } = useInfiniteScroll({\n *   hasNextPage,\n *   loadMore: fetchNextPage,\n *   skeletonRowCount: 10,\n *   minimumDelay: 300,\n *   onError: (err) => toast.error('Failed to load more'),\n * })\n * ```\n */\nexport function useInfiniteScroll({\n  hasNextPage,\n  loadMore,\n  skeletonRowCount = 5,\n  threshold = 200,\n  minimumDelay = 250,\n  onError,\n}: UseInfiniteScrollOptions): UseInfiniteScrollReturn {\n  const [isLoadingMore, setIsLoadingMore] = useState(false)\n\n  const handleLoadMore = useCallback(async () => {\n    // Guard: Don't load if already loading\n    if (isLoadingMore) return\n\n    setIsLoadingMore(true)\n    try {\n      // Run minimum delay and loadMore in parallel\n      // Skeleton stays visible for at least minimumDelay ms\n      const loadPromise = Promise.resolve(loadMore())\n      const delayPromise = minimumDelay > 0\n        ? new Promise((resolve) => setTimeout(resolve, minimumDelay))\n        : Promise.resolve()\n\n      // Wait for both to complete\n      await Promise.all([loadPromise, delayPromise])\n    } catch (error) {\n      console.error('Failed to load more:', error)\n      onError?.(error)\n    } finally {\n      setIsLoadingMore(false)\n    }\n  }, [isLoadingMore, loadMore, minimumDelay, onError])\n\n  const infiniteScrollProps: InfiniteScrollConfig = {\n    hasNextPage,\n    isLoadingMore,\n    onLoadMore: handleLoadMore,\n    skeletonRowCount,\n    threshold,\n  }\n\n  return {\n    infiniteScrollProps,\n    isLoadingMore,\n    triggerLoadMore: handleLoadMore,\n  }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]}