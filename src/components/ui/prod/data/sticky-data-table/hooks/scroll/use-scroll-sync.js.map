{"version":3,"file":"use-scroll-sync.js","sourceRoot":"/","sources":["other-repos/demo-repo/src/components/ui/prod/data/sticky-data-table/hooks/scroll/use-scroll-sync.ts"],"names":[],"mappings":"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","sourcesContent":["'use client'\n\n/**\n * StickyDataTable V2 - Scroll Sync Hook\n *\n * Synchronizes horizontal scroll between header and body containers.\n * Uses requestAnimationFrame for smooth performance.\n *\n * @module hooks/use-scroll-sync\n */\n\nimport { useState, useEffect, useCallback, useRef, useLayoutEffect } from 'react'\nimport { TABLE_CONFIG, ANIMATION_CONFIG } from '../../config'\nimport type { ScrollState } from '../../types'\n\ninterface UseScrollSyncProps {\n  headerRef: React.RefObject<HTMLDivElement | null>\n  bodyRef: React.RefObject<HTMLDivElement | null>\n}\n\ninterface UseScrollSyncReturn extends ScrollState {\n  handleScrollLeft: () => void\n  handleScrollRight: () => void\n}\n\n/**\n * Calculate scroll state from a scroll container\n */\nfunction calculateScrollState(element: HTMLDivElement): ScrollState {\n  const { scrollLeft, scrollWidth, clientWidth } = element\n  const hasOverflow = scrollWidth > clientWidth\n  const canScrollRight = scrollLeft + clientWidth < scrollWidth - TABLE_CONFIG.SCROLL_THRESHOLD\n  const canScrollLeft = scrollLeft > 0\n\n  return {\n    canScrollLeft,\n    canScrollRight,\n    showScrollIndicator: hasOverflow && canScrollRight,\n  }\n}\n\n/**\n * Hook for synchronized scrolling between header and body\n *\n * Features:\n * - Bidirectional scroll sync\n * - RAF-throttled state updates\n * - ResizeObserver for dimension changes\n * - Sub-pixel scroll handling\n */\nexport function useScrollSync({\n  headerRef,\n  bodyRef,\n}: UseScrollSyncProps): UseScrollSyncReturn {\n  const [scrollState, setScrollState] = useState<ScrollState>({\n    canScrollLeft: false,\n    canScrollRight: false,\n    showScrollIndicator: false,\n  })\n\n  // Refs for RAF throttling\n  const rafIdRef = useRef<number | undefined>(undefined)\n  const tickingRef = useRef(false)\n\n  // Track when body element changes (e.g., when unmounted/remounted due to empty state)\n  // This forces the scroll sync effect to re-run when the DOM element changes\n  const [bodyElementVersion, setBodyElementVersion] = useState(0)\n  const lastBodyElementRef = useRef<HTMLDivElement | null>(null)\n  const hasMountedRef = useRef(false)\n\n  // Check if body element has changed after initial mount\n  useLayoutEffect(() => {\n    const currentBody = bodyRef.current\n    const lastBody = lastBodyElementRef.current\n\n    // Always update the ref to track the current element\n    lastBodyElementRef.current = currentBody\n\n    // Skip the initial mount - main effect handles this correctly\n    if (!hasMountedRef.current) {\n      hasMountedRef.current = true\n      return\n    }\n\n    // Detect when body element is replaced (e.g., after empty state -> data)\n    // Only increment if we had a body before (lastBody was valid)\n    // OR if body was null and now exists (remount after empty state)\n    if (currentBody && currentBody !== lastBody) {\n      setBodyElementVersion((v) => v + 1)\n    }\n  })\n\n  // Update scroll state with RAF throttling\n  const updateScrollState = useCallback(() => {\n    const header = headerRef.current\n    if (!header) return\n\n    if (!tickingRef.current) {\n      rafIdRef.current = requestAnimationFrame(() => {\n        const newState = calculateScrollState(header)\n\n        // Only update state if values changed\n        setScrollState((prev) => {\n          if (\n            prev.canScrollLeft === newState.canScrollLeft &&\n            prev.canScrollRight === newState.canScrollRight &&\n            prev.showScrollIndicator === newState.showScrollIndicator\n          ) {\n            return prev\n          }\n          return newState\n        })\n\n        tickingRef.current = false\n      })\n      tickingRef.current = true\n    }\n  }, [headerRef])\n\n  // Set up scroll synchronization\n  useEffect(() => {\n    const header = headerRef.current\n    const body = bodyRef.current\n\n    if (!header || !body) return\n\n    // Sync body scroll when header scrolls\n    const handleHeaderScroll = () => {\n      // Skip sub-pixel differences\n      if (Math.abs(body.scrollLeft - header.scrollLeft) < ANIMATION_CONFIG.SCROLL_SYNC_THRESHOLD) {\n        return\n      }\n      body.scrollLeft = header.scrollLeft\n      updateScrollState()\n    }\n\n    // Sync header scroll when body scrolls\n    const handleBodyScroll = () => {\n      // Skip sub-pixel differences\n      if (Math.abs(header.scrollLeft - body.scrollLeft) < ANIMATION_CONFIG.SCROLL_SYNC_THRESHOLD) {\n        return\n      }\n      header.scrollLeft = body.scrollLeft\n      updateScrollState()\n    }\n\n    // Sync scroll positions (used on resize and when detecting drift)\n    const syncScrollPositions = () => {\n      if (!header || !body) return\n\n      // Always sync body to header's position to maintain consistency\n      // This handles cases where scrollWidth differs between containers\n      // (can happen due to CSS Grid fr unit calculations in different contexts)\n      if (Math.abs(body.scrollLeft - header.scrollLeft) >= ANIMATION_CONFIG.SCROLL_SYNC_THRESHOLD) {\n        body.scrollLeft = header.scrollLeft\n      }\n    }\n\n    // Watch for size changes - sync positions AND update state\n    const resizeObserver = new ResizeObserver(() => {\n      // First sync scroll positions to prevent drift after re-renders\n      syncScrollPositions()\n      // Then update the scroll state\n      updateScrollState()\n    })\n\n    resizeObserver.observe(header)\n    resizeObserver.observe(body)\n\n    // Add scroll listeners with passive for better performance\n    header.addEventListener('scroll', handleHeaderScroll, { passive: true })\n    body.addEventListener('scroll', handleBodyScroll, { passive: true })\n\n    // Initial sync and calculation\n    syncScrollPositions()\n    updateScrollState()\n\n    return () => {\n      if (rafIdRef.current) {\n        cancelAnimationFrame(rafIdRef.current)\n      }\n      // Reset ticking flag so it doesn't block subsequent effect runs\n      tickingRef.current = false\n      header.removeEventListener('scroll', handleHeaderScroll)\n      body.removeEventListener('scroll', handleBodyScroll)\n      resizeObserver.disconnect()\n    }\n    // bodyElementVersion forces re-run when body element is replaced (e.g., after empty state)\n  }, [headerRef, bodyRef, updateScrollState, bodyElementVersion])\n\n  // Arrow click handlers\n  const handleScrollLeft = useCallback(() => {\n    headerRef.current?.scrollBy({\n      left: -TABLE_CONFIG.SCROLL_AMOUNT,\n      behavior: 'smooth',\n    })\n  }, [headerRef])\n\n  const handleScrollRight = useCallback(() => {\n    headerRef.current?.scrollBy({\n      left: TABLE_CONFIG.SCROLL_AMOUNT,\n      behavior: 'smooth',\n    })\n  }, [headerRef])\n\n  return {\n    ...scrollState,\n    handleScrollLeft,\n    handleScrollRight,\n  }\n}\n\n\n"]}