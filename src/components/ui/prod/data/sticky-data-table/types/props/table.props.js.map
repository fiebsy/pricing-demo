{"version":3,"file":"table.props.js","sourceRoot":"/","sources":["other-repos/demo-repo/src/components/ui/prod/data/sticky-data-table/types/props/table.props.ts"],"names":[],"mappings":";AAAA;;;;;;GAMG","sourcesContent":["/**\n * StickyDataTable V2 - Main Table Props\n *\n * Props interface for the main StickyDataTable component.\n *\n * @module types/props/table\n */\n\nimport type { ReactNode } from 'react'\nimport type { ColumnConfig } from '../core/column.types'\nimport type { SortDirection } from '../core/sort.types'\nimport type { SelectionState } from '../core/selection.types'\nimport type { InfiniteScrollConfig } from '../infinite-scroll.types'\nimport type { SkeletonCellConfig, SkeletonScope, SkeletonStickyStateMode } from '../configuration/skeleton.types'\nimport type { ToolbarLayoutConfig } from '../../config'\nimport type { DragCloneMode } from '../../types'\nimport type { BorderConfig } from '../styling/border.types'\nimport type { BackgroundConfig } from '../styling/background.types'\n\n/**\n * Main StickyDataTable props\n *\n * @see docs/STYLING-GUIDE.md for complete styling documentation\n */\nexport interface StickyDataTableProps<T extends Record<string, unknown>> {\n  /** Data array to display */\n  data: T[]\n\n  /** Column configurations */\n  columns: ColumnConfig[]\n\n  /** Column header labels */\n  columnLabels: Record<string, string>\n\n  /**\n   * Cell render function - MUST follow styling guidelines\n   *\n   * ## MANDATORY Typography Rules:\n   *\n   * | Content Type | Classes |\n   * |-------------|---------|\n   * | Body text | `text-sm font-normal text-primary` |\n   * | Descriptions | `text-xs font-normal text-secondary` |\n   * | Status codes/IDs | `text-xs font-mono text-tertiary` |\n   *\n   * ## Correct Patterns:\n   * ```tsx\n   * case 'name':\n   *   return <span className=\"text-sm font-normal text-primary\">{row.name}</span>\n   *\n   * case 'status':\n   *   return <Badge variant=\"success\" size=\"sm\">{row.status}</Badge>\n   * ```\n   *\n   * ## Forbidden Patterns:\n   * - `font-bold`, `font-semibold` - Use `font-normal` only\n   * - `text-blue-500`, etc. - Use semantic tokens only\n   * - `text-[13px]`, `text-lg` - Use `text-sm` or `text-xs` only\n   * - Custom colored badges - Use Untitled UI Badge component\n   *\n   * @see docs/STYLING-GUIDE.md for complete documentation\n   */\n  renderCell: (columnKey: string, row: T, index: number) => ReactNode\n  /** Row click handler */\n  onRowClick?: (row: T, index: number) => void\n  /** Border radius (default: 20) */\n  borderRadius?: number\n  /** Header height override (default: 48) */\n  headerHeight?: number\n  /** Row height override (default: 46) */\n  rowHeight?: number\n  /** Border config overrides */\n  borderConfig?: Partial<BorderConfig>\n  /** Background config overrides */\n  backgroundConfig?: Partial<BackgroundConfig>\n  /** Show column control panel (default: true) */\n  showColumnControl?: boolean\n  /** Additional wrapper className */\n  className?: string\n  /** Arrow position offset override */\n  arrowPreferredTopOffset?: number\n  /** Enable row selection */\n  enableSelection?: boolean\n  /** Row ID getter (required for selection) */\n  getRowId?: (row: T, index: number) => string | number\n  /** Export all rows handler */\n  exportAll?: () => void | Promise<void>\n  /** Export selected rows handler */\n  exportSelected?: (selectionState: SelectionState) => void | Promise<void>\n  /** Custom export toolbar */\n  exportToolbar?: ReactNode\n  /** Default hidden columns (backward compatibility) */\n  defaultHiddenColumns?: string[]\n  /** Default visible columns (takes precedence over defaultHiddenColumns) */\n  defaultVisibleColumns?: string[]\n  /** Column groups for organized dropdown */\n  columnGroups?: Array<{\n    label: string\n    keys: string[]\n  }>\n  /** Left side toolbar slot (filters, search, or any custom content) */\n  leftToolbar?: ReactNode\n  /** Right side toolbar slot (search, buttons, or any custom content - appears left of export button) */\n  rightToolbar?: ReactNode\n  /** Show count display in toolbar (left side) */\n  showCount?: boolean\n  /** Total count of items (for count display) */\n  totalCount?: number\n  /** Label for count display (e.g., \"orders\", \"contracts\") - defaults to \"items\" */\n  countLabel?: string\n  /** Optional ID for testing */\n  testId?: string\n\n  // ============================================================================\n  // TOOLBAR LAYOUT\n  // ============================================================================\n\n  /**\n   * Toolbar layout configuration\n   *\n   * Controls toolbar positioning and spacing:\n   * - `position`: 'above' (default) or 'integrated' (in header gap)\n   * - `toolbarToCountGap`: Gap between toolbar row and count row (default: 6px)\n   * - `toolbarBottomMargin`: Bottom margin of toolbar section (default: 16px)\n   * - `headerGap`: Header gap height for integrated mode (default: 12px)\n   * - `integratedPadding`: Padding when toolbar is integrated\n   *\n   * @example\n   * ```tsx\n   * <StickyDataTable\n   *   toolbarLayout={{\n   *     position: 'integrated',\n   *     headerGap: 48, // Taller header gap to fit toolbar\n   *   }}\n   * />\n   * ```\n   */\n  toolbarLayout?: ToolbarLayoutConfig\n\n  // ============================================================================\n  // INFINITE SCROLL (NEW UNIFIED API)\n  // ============================================================================\n\n  /**\n   * Unified infinite scroll configuration\n   *\n   * When provided, the table automatically:\n   * - Detects when user scrolls to bottom\n   * - Calls onLoadMore when hasNextPage is true\n   * - Renders LoadMoreSkeleton using the table's own column/style configuration\n   *\n   * This eliminates manual LoadMoreSkeleton setup and ensures visual consistency.\n   *\n   * @example\n   * ```tsx\n   * <StickyDataTable\n   *   infiniteScroll={{\n   *     hasNextPage,\n   *     isLoadingMore,\n   *     onLoadMore: fetchNextPage,\n   *     skeletonRowCount: 10,\n   *   }}\n   * />\n   * ```\n   */\n  infiniteScroll?: InfiniteScrollConfig\n\n  // ============================================================================\n  // LEGACY INFINITE SCROLL / LOADING (deprecated - use infiniteScroll)\n  // ============================================================================\n\n  /**\n   * @deprecated Use infiniteScroll.customIndicator instead\n   * Content to display at the bottom of the table body (e.g. loading skeleton)\n   */\n  loadingIndicator?: ReactNode\n  /**\n   * @deprecated Use infiniteScroll.onLoadMore instead\n   * Callback when bottom of table is reached\n   */\n  onEndReached?: () => void\n  /**\n   * @deprecated Use infiniteScroll.threshold instead\n   * Distance in pixels from bottom to trigger onEndReached (default: 200)\n   */\n  onEndReachedThreshold?: number\n\n  // ============================================================================\n  // SERVER-SIDE SORTING (for paginated data)\n  // ============================================================================\n\n  /**\n   * Enable server-side sorting. When true, disables client-side sorting\n   * and calls onServerSort when column headers are clicked.\n   */\n  serverSideSort?: boolean\n  /**\n   * Callback when sort changes. Only called when serverSideSort is true.\n   * Receives column key and new direction.\n   */\n  onServerSort?: (columnKey: string, direction: SortDirection) => void\n  /** Current server sort column (for UI indicator) */\n  serverSortColumn?: string | null\n  /** Current server sort direction */\n  serverSortDirection?: SortDirection\n\n  // ============================================================================\n  // COLUMN REORDERING\n  // ============================================================================\n\n  /**\n   * Enable column reordering via drag-and-drop in the header.\n   * When enabled, non-sticky columns can be reordered by dragging.\n   * A drag handle icon appears on hover, positioned opposite to column alignment.\n   * @default true\n   */\n  enableColumnReorder?: boolean\n\n  /**\n   * Callback when columns are reordered via drag-and-drop.\n   * Receives the key of the dragged column and the key of the target position.\n   * Use with useColumnConfiguration().reorderColumns for state management.\n   *\n   * Using keys instead of indices ensures correct reordering even when\n   * some columns are hidden (indices would mismatch between visible and full arrays).\n   *\n   * @example\n   * ```tsx\n   * const columnConfig = useColumnConfiguration({ columns, ... })\n   *\n   * <StickyDataTable\n   *   enableColumnReorder\n   *   onReorderColumns={columnConfig.reorderColumns}\n   * />\n   * ```\n   */\n  onReorderColumns?: (fromKey: string, toKey: string, insertAtEnd?: boolean) => void\n\n  /**\n   * Whether column configuration has completed hydration from localStorage.\n   * When false, column reorder animations are suppressed to prevent the\n   * visual \"shift\" that occurs when saved column order differs from defaults.\n   *\n   * Get this from useColumnConfiguration().isHydrated\n   *\n   * @example\n   * ```tsx\n   * const columnConfig = useColumnConfiguration({ columns, storageKey: 'my-table' })\n   *\n   * <StickyDataTable\n   *   enableColumnReorder\n   *   onReorderColumns={columnConfig.reorderColumns}\n   *   isColumnConfigHydrated={columnConfig.isHydrated}\n   * />\n   * ```\n   */\n  isColumnConfigHydrated?: boolean\n\n  /**\n   * Drag clone visual mode for column reordering.\n   * - 'floating': Shows a floating clone near the cursor (default)\n   * - 'inline': Dragged column slides with cursor, others stay in place\n   *\n   * @default 'floating'\n   */\n  dragCloneMode?: DragCloneMode\n\n  /**\n   * Threshold for triggering column swap during drag (inline mode).\n   * Value between 0 and 1 representing percentage of column width.\n   * Lower values = more sensitive (swap triggers with less dragging).\n   *\n   * @default 0.5 (swap triggers when dragged column center passes target's midpoint)\n   * @example 0.35 = more sensitive, good for wide columns\n   * @example 0.25 = very sensitive\n   */\n  dragSwapThreshold?: number\n\n  // ============================================================================\n  // EMPTY STATE\n  // ============================================================================\n\n  /**\n   * Custom empty state when table has no data.\n   * If provided, renders instead of the table body when data is empty.\n   */\n  emptyState?: ReactNode\n\n  /**\n   * Custom empty state when search/filter yields no results.\n   * If provided, renders instead of the table body when search returns no matches.\n   * Takes a search term parameter to display in the message.\n   */\n  noResultsState?: ReactNode\n\n  /**\n   * Current search term (used for empty state message).\n   * When provided with noResultsState, displays \"No results for {searchTerm}\"\n   */\n  searchTerm?: string\n\n  /**\n   * Whether filters are currently active (besides search).\n   * When true, shows noResultsState instead of emptyState when data is empty.\n   * This allows showing \"Clear filters\" button even when there's no search term.\n   */\n  hasActiveFilters?: boolean\n\n  /**\n   * Loading state - suppresses empty states during data fetching.\n   * When true, empty states won't render even if data is empty.\n   * Use this to prevent flickering when clearing search/filters.\n   */\n  isLoading?: boolean\n\n  // ============================================================================\n  // SKELETON CONFIGURATION\n  // ============================================================================\n\n  /**\n   * Skeleton configuration for loading states.\n   *\n   * When `isLoading` is true and data is empty, the table renders skeleton rows\n   * while preserving the real toolbar (with Export, Column Control, etc.).\n   *\n   * This eliminates the need to manually reconstruct the toolbar in skeleton mode.\n   *\n   * @example\n   * ```tsx\n   * <StickyDataTable\n   *   data={data}\n   *   isLoading={!isHydrated}\n   *   skeletonConfig={{\n   *     scope: 'rows-only',\n   *     initialRowCount: 16,\n   *     bodyCellConfig: { height: 16, widthMode: 'auto' }\n   *   }}\n   *   leftToolbar={<FilterToolbar />}\n   *   exportAll={handleExport}\n   * />\n   * ```\n   */\n  skeletonConfig?: {\n    /**\n     * Skeleton scope - what parts show skeletons\n     * - 'rows-only': Real toolbar + header, skeleton only for body rows (recommended)\n     * - 'table-only': Real toolbar, skeleton for header + body\n     * - 'full': Skeleton for toolbar, header, and body (testing only)\n     * @default 'rows-only'\n     */\n    scope?: SkeletonScope\n    /** Number of skeleton rows for initial load (default: 10) */\n    initialRowCount?: number\n    /** Number of skeleton rows for infinite scroll (default: 5) */\n    infiniteScrollRowCount?: number\n    /** Header cell skeleton appearance */\n    headerCellConfig?: Partial<SkeletonCellConfig>\n    /** Body cell skeleton appearance */\n    bodyCellConfig?: Partial<SkeletonCellConfig>\n    /** Checkbox skeleton size in pixels (default: 16) */\n    checkboxSize?: number\n    /** Sticky state simulation mode (default: 'auto') */\n    simulateStickyState?: SkeletonStickyStateMode\n  }\n\n  // ============================================================================\n  // FILTER STATUS BAR\n  // ============================================================================\n\n  /**\n   * Filter status bar - floating overlay at bottom of table.\n   * Pass a FilterStatusBar component to display filter state information.\n   *\n   * @example\n   * ```tsx\n   * <StickyDataTable\n   *   filterStatusBar={\n   *     <FilterStatusBar\n   *       visibleCount={filteredItems.length}\n   *       totalCount={totalCount}\n   *       filterByLabel=\"Clawed back\"\n   *       activeFilterCount={2}\n   *       visible={hasFilters}\n   *     />\n   *   }\n   * />\n   * ```\n   */\n  filterStatusBar?: ReactNode\n}\n"]}