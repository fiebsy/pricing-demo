{"version":3,"file":"use-dimensions.js","sourceRoot":"/","sources":["other-repos/demo-repo/src/components/ui/deprecated/skwircle/core/use-dimensions.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * useDimensions Hook\n *\n * Tracks element dimensions using ResizeObserver.\n * Safari-optimized with debouncing.\n */\n\n'use client'\n\nimport { useCallback, useEffect, useLayoutEffect, useMemo, useRef, useState } from 'react'\n\ninterface UseDimensionsOptions {\n  /** Callback when dimensions change */\n  onDimensionsChange?: (width: number, height: number) => void\n  /** Whether to fade in after measurement */\n  fadeIn?: boolean\n  /** Initial dimensions for SSR */\n  initialDimensions?: { width: number; height: number }\n}\n\ninterface UseDimensionsResult {\n  /** Current dimensions */\n  dimensions: { width: number; height: number }\n  /** Whether first measurement has completed */\n  hasMeasured: boolean\n}\n\n/**\n * Hook to track element dimensions using ResizeObserver.\n *\n * @param contentRef - Ref to the element to measure\n * @param options - Configuration options\n */\nexport function useDimensions(\n  contentRef: React.RefObject<HTMLDivElement | null>,\n  options: UseDimensionsOptions = {}\n): UseDimensionsResult {\n  const { onDimensionsChange, fadeIn = true, initialDimensions } = options\n\n  const resizeTimeoutRef = useRef<number | null>(null)\n  const [dimensions, setDimensions] = useState(() => initialDimensions ?? { width: 0, height: 0 })\n  const [hasMeasured, setHasMeasured] = useState(() => (!fadeIn ? true : !!initialDimensions))\n\n  // Use refs to avoid re-running effects\n  const dimensionsRef = useRef(dimensions)\n  const hasMeasuredRef = useRef(hasMeasured)\n  const onDimensionsChangeRef = useRef(onDimensionsChange)\n\n  useEffect(() => {\n    dimensionsRef.current = dimensions\n  }, [dimensions])\n\n  useEffect(() => {\n    hasMeasuredRef.current = hasMeasured\n  }, [hasMeasured])\n\n  useEffect(() => {\n    onDimensionsChangeRef.current = onDimensionsChange\n  }, [onDimensionsChange])\n\n  // Measure synchronously before first paint to prevent flash\n  useLayoutEffect(() => {\n    const el = contentRef.current\n    if (!el) return\n\n    const rect = el.getBoundingClientRect()\n    const nextWidth = Math.ceil(rect.width)\n    const nextHeight = Math.ceil(rect.height)\n\n    if (nextWidth > 0 && nextHeight > 0) {\n      const prev = dimensionsRef.current\n      const widthDiff = Math.abs(nextWidth - prev.width)\n      const heightDiff = Math.abs(nextHeight - prev.height)\n\n      if (prev.width === 0 || prev.height === 0 || widthDiff > 1 || heightDiff > 1) {\n        dimensionsRef.current = { width: nextWidth, height: nextHeight }\n        setDimensions({ width: nextWidth, height: nextHeight })\n        onDimensionsChangeRef.current?.(nextWidth, nextHeight)\n      }\n\n      if (fadeIn && !hasMeasuredRef.current) {\n        hasMeasuredRef.current = true\n        setHasMeasured(true)\n      }\n    }\n  }, [contentRef, fadeIn])\n\n  // Set up ResizeObserver for ongoing dimension tracking\n  useEffect(() => {\n    if (!contentRef.current) return\n\n    const resizeObserver = new ResizeObserver((entries) => {\n      // Cancel any pending update\n      if (resizeTimeoutRef.current !== null) {\n        cancelAnimationFrame(resizeTimeoutRef.current)\n      }\n\n      // Schedule update for next frame (Safari optimization)\n      resizeTimeoutRef.current = requestAnimationFrame(() => {\n        for (const entry of entries) {\n          const { width, height } = entry.contentRect\n          const newWidth = Math.ceil(width)\n          const newHeight = Math.ceil(height)\n\n          // Only update if change is significant (> 1px)\n          const prev = dimensionsRef.current\n          const widthDiff = Math.abs(newWidth - prev.width)\n          const heightDiff = Math.abs(newHeight - prev.height)\n\n          if (widthDiff > 1 || heightDiff > 1 || (newWidth > 0 && prev.width === 0)) {\n            dimensionsRef.current = { width: newWidth, height: newHeight }\n            setDimensions({ width: newWidth, height: newHeight })\n            onDimensionsChangeRef.current?.(newWidth, newHeight)\n\n            // Trigger fade-in after first measurement\n            if (fadeIn && !hasMeasuredRef.current) {\n              requestAnimationFrame(() => {\n                hasMeasuredRef.current = true\n                setHasMeasured(true)\n              })\n            }\n          }\n        }\n        resizeTimeoutRef.current = null\n      })\n    })\n\n    resizeObserver.observe(contentRef.current)\n    return () => {\n      resizeObserver.disconnect()\n      if (resizeTimeoutRef.current !== null) {\n        cancelAnimationFrame(resizeTimeoutRef.current)\n      }\n    }\n  }, [contentRef, fadeIn])\n\n  return { dimensions, hasMeasured }\n}\n"]}