{"version":3,"file":"column-processor.js","sourceRoot":"/","sources":["other-repos/demo-repo/src/components/ui/deprecated/sticky-data-table/utils/column-processor.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * StickyDataTable V2 - Column Processor\n *\n * Unified column processing logic shared between StickyDataTable and TableSkeleton.\n * This ensures both components use identical column calculations for perfect alignment.\n *\n * @module utils/column-processor\n */\n\nimport type { ColumnConfig, ComputedColumn, StickyState, BorderConfig, BackgroundConfig } from '../types'\nimport { computeColumnOffsets, separateColumns, calculateTotalStickyWidth, generateGridTemplate } from './grid'\nimport { createBorderConfig, createBackgroundConfig, createInitialStickyState } from '../config'\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\n/**\n * Options for processing columns\n */\nexport interface ColumnProcessorOptions {\n  /** Raw column configuration */\n  columns: ColumnConfig[]\n  /** Enable selection checkbox column */\n  enableSelection?: boolean\n  /** Set of visible column keys (filters columns) */\n  visibleColumnKeys?: Set<string>\n  /** Simulate scrollable state for skeleton */\n  simulateScrollable?: boolean\n  /** Border configuration overrides */\n  borderConfig?: Partial<BorderConfig>\n  /** Background configuration overrides */\n  backgroundConfig?: Partial<BackgroundConfig>\n}\n\n/**\n * Result of column processing\n */\nexport interface ProcessedColumnsResult {\n  /** All processed columns with computed offsets */\n  allColumns: ComputedColumn[]\n  /** Sticky columns only */\n  stickyColumns: ComputedColumn[]\n  /** Scrollable (non-sticky) columns only */\n  scrollableColumns: ComputedColumn[]\n  /** CSS grid template string */\n  gridTemplate: string\n  /** Total width of sticky columns in pixels */\n  totalStickyWidth: number\n  /** Sticky state (simulated or initial) */\n  stickyState: StickyState\n  /** Merged border configuration */\n  borderConfig: BorderConfig\n  /** Merged background configuration */\n  backgroundConfig: BackgroundConfig\n  /** Whether checkbox column was added */\n  hasCheckboxColumn: boolean\n}\n\n// ============================================================================\n// CONSTANTS\n// ============================================================================\n\n/**\n * Checkbox column configuration\n * Added as first sticky column when selection is enabled\n */\nconst CHECKBOX_COLUMN: ColumnConfig = {\n  key: '__checkbox',\n  width: 48,\n  align: 'center',\n  isSticky: true,\n  stickyLeft: 0,\n  sortable: false,\n}\n\n// ============================================================================\n// CORE PROCESSING\n// ============================================================================\n\n/**\n * Process columns with unified logic\n *\n * This function handles:\n * 1. Adding checkbox column if selection enabled\n * 2. Adjusting sticky offsets for existing columns\n * 3. Filtering by visibility\n * 4. Computing sticky offsets\n * 5. Generating grid template\n * 6. Creating sticky state\n *\n * @param options - Column processor options\n * @returns Processed columns result\n *\n * @example\n * ```tsx\n * // Basic usage\n * const result = processColumns({ columns: myColumns })\n *\n * // With selection\n * const result = processColumns({\n *   columns: myColumns,\n *   enableSelection: true,\n * })\n *\n * // With visibility filter\n * const result = processColumns({\n *   columns: myColumns,\n *   visibleColumnKeys: new Set(['id', 'name', 'amount']),\n * })\n *\n * // For skeleton with scrollable simulation\n * const result = processColumns({\n *   columns: myColumns,\n *   enableSelection: true,\n *   simulateScrollable: true,\n * })\n * ```\n */\nexport function processColumns(options: ColumnProcessorOptions): ProcessedColumnsResult {\n  const {\n    columns,\n    enableSelection = false,\n    visibleColumnKeys,\n    simulateScrollable = false,\n    borderConfig: borderConfigOverrides,\n    backgroundConfig: backgroundConfigOverrides,\n  } = options\n\n  let processedColumns = [...columns]\n  let hasCheckboxColumn = false\n\n  // Step 1: Add checkbox column if selection enabled\n  if (enableSelection) {\n    // Check if checkbox column already exists\n    const hasExistingCheckbox = processedColumns.some((col) => col.key === '__checkbox')\n\n    if (!hasExistingCheckbox) {\n      // Adjust stickyLeft for existing sticky columns\n      processedColumns = processedColumns.map((col) => {\n        if (col.isSticky && col.stickyLeft !== undefined) {\n          return { ...col, stickyLeft: col.stickyLeft + CHECKBOX_COLUMN.width }\n        }\n        return col\n      })\n\n      // Add checkbox as first column\n      processedColumns = [CHECKBOX_COLUMN, ...processedColumns]\n      hasCheckboxColumn = true\n    } else {\n      hasCheckboxColumn = true\n    }\n  }\n\n  // Step 2: Filter by visibility if provided\n  if (visibleColumnKeys && visibleColumnKeys.size > 0) {\n    processedColumns = processedColumns.filter((col) => {\n      // Always include checkbox column\n      if (col.key === '__checkbox') return true\n      return visibleColumnKeys.has(col.key)\n    })\n  }\n\n  // Step 3: Compute column offsets\n  const computedColumns = computeColumnOffsets(processedColumns)\n\n  // Step 4: Separate into sticky and scrollable\n  const { stickyColumns, scrollableColumns } = separateColumns(computedColumns)\n\n  // Step 5: Generate grid template\n  const gridTemplate = generateGridTemplate(stickyColumns, scrollableColumns)\n\n  // Step 6: Calculate total sticky width\n  const totalStickyWidth = calculateTotalStickyWidth(stickyColumns)\n\n  // Step 7: Create sticky state\n  const stickyState: StickyState = simulateScrollable\n    ? {\n        showLeftArrow: false,\n        showRightArrow: true,\n        hasArrows: true,\n        useEnhancedStyling: true,\n      }\n    : createInitialStickyState()\n\n  // Step 8: Merge configurations\n  const borderConfig = createBorderConfig(borderConfigOverrides)\n  const backgroundConfig = createBackgroundConfig(backgroundConfigOverrides)\n\n  return {\n    allColumns: computedColumns,\n    stickyColumns,\n    scrollableColumns,\n    gridTemplate,\n    totalStickyWidth,\n    stickyState,\n    borderConfig,\n    backgroundConfig,\n    hasCheckboxColumn,\n  }\n}\n\n// ============================================================================\n// HELPERS\n// ============================================================================\n\n/**\n * Create visible column keys set from default visible columns array\n *\n * @param columns - All columns\n * @param defaultVisibleColumns - Array of visible column keys\n * @returns Set of visible column keys\n */\nexport function createVisibleColumnKeys(\n  columns: ColumnConfig[],\n  defaultVisibleColumns?: string[]\n): Set<string> | undefined {\n  if (!defaultVisibleColumns || defaultVisibleColumns.length === 0) {\n    return undefined\n  }\n\n  const visibleSet = new Set(defaultVisibleColumns)\n\n  // Filter to only include keys that exist in columns\n  const validKeys = columns.map((c) => c.key).filter((key) => visibleSet.has(key))\n\n  return new Set(validKeys)\n}\n\n/**\n * Check if columns configuration has any sticky columns\n *\n * @param columns - Column configuration array\n * @returns True if any column is sticky\n */\nexport function hasStickyColumns(columns: ColumnConfig[]): boolean {\n  return columns.some((col) => col.isSticky)\n}\n\n/**\n * Count total number of sticky columns\n *\n * @param columns - Column configuration array\n * @returns Number of sticky columns\n */\nexport function countStickyColumns(columns: ColumnConfig[]): number {\n  return columns.filter((col) => col.isSticky).length\n}\n\n/**\n * Get the rightmost sticky column\n *\n * @param columns - Computed columns\n * @returns The last sticky column or undefined\n */\nexport function getRightmostStickyColumn(columns: ComputedColumn[]): ComputedColumn | undefined {\n  const stickyColumns = columns.filter((col) => col.isSticky)\n  return stickyColumns[stickyColumns.length - 1]\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n"]}