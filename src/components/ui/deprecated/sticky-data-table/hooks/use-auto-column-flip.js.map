{"version":3,"file":"use-auto-column-flip.js","sourceRoot":"/","sources":["other-repos/demo-repo/src/components/ui/deprecated/sticky-data-table/hooks/use-auto-column-flip.ts"],"names":[],"mappings":"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","sourcesContent":["'use client'\n\n/**\n * StickyDataTable V2 - Auto Column FLIP Animation Hook\n *\n * Automatically detects column changes and applies FLIP animations.\n * No manual capture/animate calls needed - just pass the container ref\n * and column keys, and it handles the rest.\n *\n * @module hooks/use-auto-column-flip\n */\n\nimport { useLayoutEffect, useRef } from 'react'\nimport { ANIMATION_CONFIG } from '../config'\n\n// ============================================================================\n// TYPES\n// ============================================================================\n\ninterface ColumnRect {\n  left: number\n  width: number\n}\n\ninterface UseAutoColumnFlipOptions {\n  /** Enable/disable animations */\n  enabled?: boolean\n  /** Animation duration in ms */\n  duration?: number\n  /** Minimum movement (px) to trigger animation */\n  threshold?: number\n  /** CSS easing function */\n  easing?: string\n  /** Key of the column being dragged (excluded from animation) */\n  draggedKey?: string | null\n  /** Ref containing the dragged key (read at effect time for correct timing) */\n  draggedKeyRef?: React.RefObject<string | null>\n  /** Whether the component is still hydrating from localStorage (suppresses animation) */\n  isHydrating?: boolean\n}\n\n// ============================================================================\n// HOOK\n// ============================================================================\n\n/**\n * Auto-FLIP hook for column animations\n *\n * Usage:\n * ```tsx\n * const containerRef = useRef<HTMLDivElement>(null)\n * useAutoColumnFlip(containerRef, visibleColumnKeys)\n *\n * return <div ref={containerRef}>...</div>\n * ```\n */\nexport function useAutoColumnFlip(\n  containerRef: React.RefObject<HTMLElement | null>,\n  columnKeys: Set<string> | string[],\n  options: UseAutoColumnFlipOptions = {}\n) {\n  const {\n    enabled = true,\n    duration = ANIMATION_CONFIG.COLUMN_ANIMATION_DURATION,\n    threshold = 2,\n    easing = 'cubic-bezier(0.2, 0.8, 0.2, 1)',\n    draggedKey = null,\n    draggedKeyRef,\n    isHydrating = false,\n  } = options\n\n  // Store previous positions\n  const prevPositionsRef = useRef<Map<string, ColumnRect>>(new Map())\n  const prevKeysRef = useRef<string[]>([])\n  const isFirstRenderRef = useRef(true)\n\n  // Convert to array for comparison\n  const keysArray = Array.isArray(columnKeys) ? columnKeys : [...columnKeys]\n  const keysString = keysArray.join(',')\n\n  useLayoutEffect(() => {\n    if (!enabled) return\n\n    const container = containerRef.current\n    if (!container) return\n\n    // Check for reduced motion\n    if (typeof window !== 'undefined' && window.matchMedia('(prefers-reduced-motion: reduce)').matches) {\n      return\n    }\n\n    // Skip animation during hydration (localStorage loading)\n    // This prevents the flash when saved column order differs from defaults\n    if (isHydrating) {\n      // Still capture positions so we're ready for user-initiated changes\n      capturePositions(container, prevPositionsRef.current)\n      prevKeysRef.current = keysArray\n      return\n    }\n\n    // Skip animation on first render\n    if (isFirstRenderRef.current) {\n      isFirstRenderRef.current = false\n      // Capture initial positions for next change\n      capturePositions(container, prevPositionsRef.current)\n      prevKeysRef.current = keysArray\n      return\n    }\n\n    // Check if columns actually changed\n    const prevKeys = prevKeysRef.current\n    const keysChanged = keysString !== prevKeys.join(',')\n\n    if (!keysChanged) {\n      // No change, just update positions for next time\n      capturePositions(container, prevPositionsRef.current)\n      return\n    }\n\n    // Determine which columns actually changed INDEX (not just position)\n    // Only these columns should animate\n    const changedIndexKeys = new Set<string>()\n    keysArray.forEach((key, newIndex) => {\n      const oldIndex = prevKeys.indexOf(key)\n      if (oldIndex !== -1 && oldIndex !== newIndex) {\n        changedIndexKeys.add(key)\n      }\n    })\n\n    // Read dragged key from ref at effect time (more reliable than render-time value)\n    const effectDraggedKey = draggedKeyRef?.current ?? draggedKey\n\n    // FLIP: Animate only columns that changed index\n    const oldPositions = prevPositionsRef.current\n    const columns = container.querySelectorAll('[data-column-key]')\n    const containerRect = container.getBoundingClientRect()\n    const animations: Animation[] = []\n\n    columns.forEach((el) => {\n      const key = el.getAttribute('data-column-key')\n      if (!key) return\n\n      // Skip columns that didn't change index\n      if (!changedIndexKeys.has(key)) {\n        return\n      }\n\n      // Skip the dragged column (it snaps, others animate)\n      if (effectDraggedKey && key === effectDraggedKey) {\n        return\n      }\n\n      const oldPos = oldPositions.get(key)\n      if (!oldPos) {\n        // New column - skip, it has its own enter animation\n        return\n      }\n\n      // Skip columns with enter/leave animations\n      if (el.hasAttribute('data-column-entering') || el.hasAttribute('data-column-leaving')) {\n        return\n      }\n\n      // Calculate new position relative to container (same as captured positions)\n      const newRect = el.getBoundingClientRect()\n      const newLeft = newRect.left - containerRect.left\n      const deltaX = oldPos.left - newLeft\n\n      if (Math.abs(deltaX) <= threshold) {\n        return // Movement too small\n      }\n\n      // FLIP animation using WAAPI\n      try {\n        const animation = (el as HTMLElement).animate(\n          [\n            { transform: `translateX(${deltaX}px)` },\n            { transform: 'translateX(0)' },\n          ],\n          {\n            duration,\n            easing,\n            fill: 'none',\n          }\n        )\n        animations.push(animation)\n      } catch (e) {\n        console.warn('[AutoFLIP] Animation failed:', e)\n      }\n    })\n\n    // Update stored state for next change\n    prevKeysRef.current = keysArray\n    // Capture new positions after a tick (after animations start)\n    requestAnimationFrame(() => {\n      capturePositions(container, prevPositionsRef.current)\n    })\n\n  }, [keysString, enabled, duration, threshold, easing, containerRef, keysArray, draggedKey, isHydrating])\n}\n\n/**\n * Capture current positions of all columns in a container\n * Uses container-relative positions to avoid scroll/viewport offset issues\n */\nfunction capturePositions(container: HTMLElement, storage: Map<string, ColumnRect>) {\n  storage.clear()\n  const columns = container.querySelectorAll('[data-column-key]')\n  const containerRect = container.getBoundingClientRect()\n\n  columns.forEach((el) => {\n    const key = el.getAttribute('data-column-key')\n    if (!key) return\n\n    const rect = el.getBoundingClientRect()\n    // Store position relative to container, not viewport\n    storage.set(key, {\n      left: rect.left - containerRect.left,\n      width: rect.width,\n    })\n  })\n}\n"]}