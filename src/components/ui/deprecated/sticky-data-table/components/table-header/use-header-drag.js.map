{"version":3,"file":"use-header-drag.js","sourceRoot":"/","sources":["other-repos/demo-repo/src/components/ui/deprecated/sticky-data-table/components/table-header/use-header-drag.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * StickyDataTable V2 - useHeaderDrag Hook\n *\n * Manages pointer-based drag-and-drop state and handlers for column reordering.\n *\n * @module components/table-header/use-header-drag\n */\n\nimport { useState, useCallback, useRef, type RefObject } from 'react'\nimport type { ComputedColumn, DragCloneMode } from '../../types'\nimport type { PointerDragState, UseHeaderDragReturn } from './types'\nimport { ANIMATION_CONFIG } from '../../config'\n\nconst INITIAL_DRAG_STATE: PointerDragState = {\n  isDragging: false,\n  draggedKey: null,\n  dragOverKey: null,\n  dropSide: null,\n  pointerX: 0,\n  pointerY: 0,\n  dragWidth: 0,\n  dragHeight: 0,\n  dragLabel: '',\n  dragAlign: 'left',\n}\n\ninterface UseHeaderDragOptions {\n  headerScrollRef: RefObject<HTMLDivElement | null>\n  allColumns: ComputedColumn[]\n  enableColumnReorder?: boolean\n  onReorderColumns?: (fromKey: string, toKey: string, insertAfter?: boolean) => void\n  externalDroppedKeyRef?: React.MutableRefObject<string | null>\n  /** Clone mode: 'floating' shows clone near cursor, 'inline' slides the actual cell */\n  cloneMode?: DragCloneMode\n}\n\n/**\n * Hook for managing header column drag-and-drop\n */\nexport function useHeaderDrag({\n  headerScrollRef,\n  allColumns,\n  enableColumnReorder = false,\n  onReorderColumns,\n  externalDroppedKeyRef,\n  cloneMode = 'inline',\n}: UseHeaderDragOptions): UseHeaderDragReturn {\n  const [dragState, setDragState] = useState<PointerDragState>(INITIAL_DRAG_STATE)\n\n  // Track the last dropped column key (persists through animation)\n  // Use external ref if provided (shared with body), otherwise create local fallback\n  const internalDroppedKeyRef = useRef<string | null>(null)\n  const lastDroppedKeyRef = externalDroppedKeyRef ?? internalDroppedKeyRef\n\n  // Ref to store column element rects for hit testing\n  const columnRectsRef = useRef<Map<string, DOMRect>>(new Map())\n\n  // Track drag start position for inline mode offset calculation\n  const dragStartXRef = useRef<number>(0)\n\n  // Track the original index of the dragged column (for inline slot-based detection)\n  const draggedOriginalIndexRef = useRef<number>(-1)\n\n  // Track ordered column keys at drag start (for slot calculation)\n  const orderedKeysAtDragStartRef = useRef<string[]>([])\n\n  /**\n   * Check if a column can be dragged\n   */\n  const isColumnDraggable = useCallback((column: ComputedColumn): boolean => {\n    if (!enableColumnReorder || !onReorderColumns) return false\n    if (column.isSticky) return false\n    if (column.key === '__checkbox') return false\n    return true\n  }, [enableColumnReorder, onReorderColumns])\n\n  /**\n   * Check if a column is a valid drop target\n   */\n  const isValidDropTarget = useCallback((column: ComputedColumn): boolean => {\n    if (!enableColumnReorder || !onReorderColumns) return false\n    if (column.isSticky) return false\n    if (column.key === '__checkbox') return false\n    return true\n  }, [enableColumnReorder, onReorderColumns])\n\n  /**\n   * Capture column positions for hit testing\n   */\n  const captureColumnRects = useCallback(() => {\n    const container = headerScrollRef.current\n    if (!container) return\n\n    columnRectsRef.current.clear()\n    const cells = container.querySelectorAll('[data-column-key]')\n    cells.forEach((cell) => {\n      const key = cell.getAttribute('data-column-key')\n      if (key) {\n        columnRectsRef.current.set(key, cell.getBoundingClientRect())\n      }\n    })\n  }, [headerScrollRef])\n\n  /**\n   * Find drop target using center-of-column detection for inline mode.\n   * The shift triggers when the CENTER of the dragged column crosses\n   * into another column's territory (past its midpoint).\n   */\n  const findDropTargetInlineMode = useCallback((x: number): { key: string; side: 'left' | 'right' } | null => {\n    const draggedKey = dragState.draggedKey\n    if (!draggedKey) return null\n\n    const originalIndex = draggedOriginalIndexRef.current\n    if (originalIndex === -1) return null\n\n    const orderedKeys = orderedKeysAtDragStartRef.current\n    if (orderedKeys.length === 0) return null\n\n    // Get the dragged column's original rect\n    const draggedRect = columnRectsRef.current.get(draggedKey)\n    if (!draggedRect) return null\n\n    // Calculate cursor displacement from drag start\n    const displacement = x - dragStartXRef.current\n\n    // Calculate the current center of the dragged column\n    // Original center + how far we've dragged\n    const originalCenter = draggedRect.left + draggedRect.width / 2\n    const currentCenter = originalCenter + displacement\n\n    // Find which column's territory the dragged column's center is now in\n    // by checking if center has crossed past another column's midpoint\n    let targetSlotIndex = originalIndex\n\n    if (displacement > 0) {\n      // Moving RIGHT - check columns to the right\n      for (let i = originalIndex + 1; i < orderedKeys.length; i++) {\n        const colKey = orderedKeys[i]\n        if (!colKey) continue\n        const colRect = columnRectsRef.current.get(colKey)\n        if (!colRect) continue\n\n        // If our center has passed this column's midpoint, we should be in its slot\n        const colMidpoint = colRect.left + colRect.width / 2\n        if (currentCenter > colMidpoint) {\n          targetSlotIndex = i\n        } else {\n          break // No need to check further\n        }\n      }\n    } else if (displacement < 0) {\n      // Moving LEFT - check columns to the left\n      for (let i = originalIndex - 1; i >= 0; i--) {\n        const colKey = orderedKeys[i]\n        if (!colKey) continue\n        const colRect = columnRectsRef.current.get(colKey)\n        if (!colRect) continue\n\n        // If our center has passed this column's midpoint (going left), we should be in its slot\n        const colMidpoint = colRect.left + colRect.width / 2\n        if (currentCenter < colMidpoint) {\n          targetSlotIndex = i\n        } else {\n          break // No need to check further\n        }\n      }\n    }\n\n    // If we haven't moved from original position, no drop target\n    if (targetSlotIndex === originalIndex) return null\n\n    // Find the column key at the target position\n    const targetKey = orderedKeys[targetSlotIndex]\n    if (!targetKey || targetKey === draggedKey) return null\n\n    const targetCol = allColumns.find(c => c.key === targetKey)\n    if (!targetCol || !isValidDropTarget(targetCol)) return null\n\n    // When moving right, drop AFTER the target; when moving left, drop BEFORE\n    const side: 'left' | 'right' = targetSlotIndex > originalIndex ? 'right' : 'left'\n    return { key: targetKey, side }\n  }, [dragState.draggedKey, allColumns, isValidDropTarget])\n\n  /**\n   * Find which column the pointer is over and which side (left/right half)\n   * Returns { key, side } where side determines insert before (left) or after (right)\n   *\n   * In FLOATING mode: Uses direct hit testing against column rects\n   * In INLINE mode: Uses slot-based calculation based on cursor displacement\n   */\n  const findDropTarget = useCallback((x: number, y: number): { key: string; side: 'left' | 'right' } | null => {\n    // INLINE MODE: Use slot-based detection (stable, no feedback loops)\n    if (cloneMode === 'inline') {\n      return findDropTargetInlineMode(x)\n    }\n\n    // FLOATING MODE: Use traditional hit testing against original rects\n    for (const [key, rect] of columnRectsRef.current.entries()) {\n      if (x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom) {\n        const col = allColumns.find((c) => c.key === key)\n        if (col && isValidDropTarget(col)) {\n          // Determine which half of the column the cursor is in\n          const midpoint = rect.left + rect.width / 2\n          const side: 'left' | 'right' = x < midpoint ? 'left' : 'right'\n          return { key, side }\n        }\n      }\n    }\n    return null\n  }, [allColumns, isValidDropTarget, cloneMode, findDropTargetInlineMode])\n\n  /**\n   * Handle pointer down on drag handle\n   */\n  const handlePointerDown = useCallback((e: React.PointerEvent, columnKey: string, label: string) => {\n    e.preventDefault()\n    e.stopPropagation()\n\n    const target = e.currentTarget as HTMLElement\n    const cell = target.closest('[data-column-key]') as HTMLElement\n    if (!cell) return\n\n    const rect = cell.getBoundingClientRect()\n\n    // Find the column to get its alignment\n    const column = allColumns.find((col) => col.key === columnKey)\n    const align = column?.isLast ? 'right' : (column?.align ?? 'left')\n\n    // Capture pointer for tracking\n    target.setPointerCapture(e.pointerId)\n\n    // Capture all column positions for hit testing\n    captureColumnRects()\n\n    // Store drag start position for inline mode\n    dragStartXRef.current = e.clientX\n\n    // For inline mode: capture original index and column order for slot-based detection\n    const draggableColumns = allColumns.filter(col =>\n      !col.isSticky && col.key !== '__checkbox'\n    )\n    orderedKeysAtDragStartRef.current = draggableColumns.map(col => col.key)\n    draggedOriginalIndexRef.current = draggableColumns.findIndex(col => col.key === columnKey)\n\n    setDragState({\n      isDragging: true,\n      draggedKey: columnKey,\n      dragOverKey: null,\n      dropSide: null,\n      pointerX: e.clientX,\n      pointerY: e.clientY,\n      dragWidth: rect.width,\n      dragHeight: rect.height,\n      dragLabel: label,\n      dragAlign: align,\n    })\n  }, [captureColumnRects, allColumns])\n\n  /**\n   * Handle pointer move during drag\n   */\n  const handlePointerMove = useCallback((e: React.PointerEvent) => {\n    if (!dragState.isDragging || !dragState.draggedKey) return\n\n    const dropTarget = findDropTarget(e.clientX, e.clientY)\n\n    // Check if drop would result in no change based on side\n    let effectiveTarget: string | null = null\n    let effectiveSide: 'left' | 'right' | null = null\n\n    if (dropTarget && dropTarget.key !== dragState.draggedKey) {\n      const fromIndex = allColumns.findIndex((col) => col.key === dragState.draggedKey)\n      const toIndex = allColumns.findIndex((col) => col.key === dropTarget.key)\n\n      // Determine if this would be a no-op based on side:\n      // - Left side (insert before): no-op if dragged column is already immediately before target\n      // - Right side (insert after): no-op if dragged column is already immediately after target\n      const isNoOp = dropTarget.side === 'left'\n        ? fromIndex === toIndex - 1  // Already immediately before\n        : fromIndex === toIndex + 1  // Already immediately after\n\n      if (!isNoOp) {\n        effectiveTarget = dropTarget.key\n        effectiveSide = dropTarget.side\n      }\n    }\n\n    setDragState((prev) => ({\n      ...prev,\n      pointerX: e.clientX,\n      pointerY: e.clientY,\n      dragOverKey: effectiveTarget,\n      dropSide: effectiveSide,\n    }))\n  }, [dragState.isDragging, dragState.draggedKey, findDropTarget, allColumns])\n\n  /**\n   * Handle pointer up - complete the drag\n   */\n  const handlePointerUp = useCallback((e: React.PointerEvent) => {\n    if (!dragState.isDragging || !dragState.draggedKey) {\n      setDragState((prev) => ({ ...prev, isDragging: false, draggedKey: null, dragOverKey: null, dropSide: null }))\n      return\n    }\n\n    const dropTarget = findDropTarget(e.clientX, e.clientY)\n\n    if (dropTarget && dropTarget.key !== dragState.draggedKey && onReorderColumns) {\n      const fromIndex = allColumns.findIndex((col) => col.key === dragState.draggedKey)\n      const toIndex = allColumns.findIndex((col) => col.key === dropTarget.key)\n\n      // Determine if this would be a no-op based on side\n      const isNoOp = dropTarget.side === 'left'\n        ? fromIndex === toIndex - 1\n        : fromIndex === toIndex + 1\n\n      if (!isNoOp) {\n        // Store the dragged key for FLIP animation\n        lastDroppedKeyRef.current = dragState.draggedKey\n\n        // Pass column keys and whether to insert after (right side) or before (left side)\n        const insertAfter = dropTarget.side === 'right'\n        onReorderColumns(dragState.draggedKey, dropTarget.key, insertAfter)\n\n        // Clear the ref after animation completes\n        setTimeout(() => {\n          lastDroppedKeyRef.current = null\n        }, ANIMATION_CONFIG.COLUMN_ANIMATION_DURATION + 50)\n      }\n    }\n\n    // Reset drag state and refs\n    setDragState(INITIAL_DRAG_STATE)\n    draggedOriginalIndexRef.current = -1\n    orderedKeysAtDragStartRef.current = []\n  }, [dragState.isDragging, dragState.draggedKey, findDropTarget, onReorderColumns, allColumns, lastDroppedKeyRef])\n\n  /**\n   * Handle pointer cancel\n   */\n  const handlePointerCancel = useCallback(() => {\n    setDragState(INITIAL_DRAG_STATE)\n    draggedOriginalIndexRef.current = -1\n    orderedKeysAtDragStartRef.current = []\n  }, [])\n\n  /**\n   * Calculate shift direction for a column based on drop position\n   *\n   * FLOATING MODE: Neighbors of drop position shift apart to create a small gap\n   * INLINE MODE: Columns between original and drop position shift to fill/make room\n   *              (like browser tab reordering)\n   */\n  const getShiftDirection = useCallback((columnKey: string, colIndex: number): 'left' | 'right' | null => {\n    if (!dragState.dragOverKey || !dragState.dropSide || !dragState.draggedKey) return null\n\n    const draggedIndex = allColumns.findIndex((c) => c.key === dragState.draggedKey)\n    const dropTargetIndex = allColumns.findIndex((c) => c.key === dragState.dragOverKey)\n    if (draggedIndex === -1 || dropTargetIndex === -1) return null\n\n    // Don't shift the dragged column itself\n    if (columnKey === dragState.draggedKey) return null\n\n    // INLINE MODE: Columns between original and drop position shift to reorder\n    if (cloneMode === 'inline') {\n      // Calculate effective drop index\n      const effectiveDropIndex = dragState.dropSide === 'right' ? dropTargetIndex + 1 : dropTargetIndex\n\n      // Dragging RIGHT (to a later position)\n      if (effectiveDropIndex > draggedIndex) {\n        // Columns between dragged position and drop position shift LEFT\n        if (colIndex > draggedIndex && colIndex < effectiveDropIndex) {\n          return 'left'\n        }\n        // The drop target shifts left if dropping on its right side\n        if (colIndex === dropTargetIndex && dragState.dropSide === 'right') {\n          return 'left'\n        }\n      }\n      // Dragging LEFT (to an earlier position)\n      else if (effectiveDropIndex < draggedIndex) {\n        // Columns between drop position and dragged position shift RIGHT\n        if (colIndex >= effectiveDropIndex && colIndex < draggedIndex) {\n          return 'right'\n        }\n      }\n\n      return null\n    }\n\n    // FLOATING MODE: Just shift immediate neighbors to create gap for drop indicator\n    if (dragState.dropSide === 'left') {\n      if (columnKey === dragState.dragOverKey) {\n        return 'right'\n      } else if (colIndex === dropTargetIndex - 1) {\n        return 'left'\n      }\n    } else {\n      if (columnKey === dragState.dragOverKey) {\n        return 'left'\n      } else if (colIndex === dropTargetIndex + 1) {\n        return 'right'\n      }\n    }\n\n    return null\n  }, [dragState.dragOverKey, dragState.dropSide, dragState.draggedKey, allColumns, cloneMode])\n\n  /**\n   * Get inline offset for the dragged column (inline mode only)\n   * Returns the translateX value in pixels, or null if not applicable\n   */\n  const getInlineOffset = useCallback((columnKey: string): number | null => {\n    if (cloneMode !== 'inline') return null\n    if (!dragState.isDragging) return null\n    if (columnKey !== dragState.draggedKey) return null\n\n    // Calculate offset from drag start position\n    return dragState.pointerX - dragStartXRef.current\n  }, [cloneMode, dragState.isDragging, dragState.draggedKey, dragState.pointerX])\n\n  /**\n   * Get the shift amount in pixels for a column\n   * In floating mode: small gap (4px) - just creates space for drop indicator\n   * In inline mode: full width of the dragged column - columns actually reposition\n   */\n  const getShiftAmount = useCallback((): number => {\n    if (cloneMode === 'inline' && dragState.draggedKey) {\n      // Get the width of the dragged column from captured rects\n      const draggedRect = columnRectsRef.current?.get(dragState.draggedKey)\n      if (draggedRect) {\n        return draggedRect.width\n      }\n    }\n    // Small gap for floating mode (creates space for drop indicator)\n    return 4\n  }, [cloneMode, dragState.draggedKey])\n\n  return {\n    dragState,\n    columnRectsRef,\n    lastDroppedKeyRef,\n    isColumnDraggable,\n    handlePointerDown,\n    handlePointerMove,\n    handlePointerUp,\n    handlePointerCancel,\n    getShiftDirection,\n    getInlineOffset,\n    getShiftAmount,\n    cloneMode,\n  }\n}\n"]}