{"version":3,"file":"table-body.js","sourceRoot":"/","sources":["other-repos/demo-repo/src/components/ui/deprecated/sticky-data-table/components/table-body.tsx"],"names":[],"mappings":"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","sourcesContent":["'use client'\n\n/**\n * StickyDataTable V2 - TableBody Component\n *\n * Renders the scrollable table body with rows.\n * Optimized for large datasets with memoization.\n *\n * @module components/table-body\n */\n\nimport { memo, useEffect, useRef, type RefObject, type ReactNode } from 'react'\nimport * as React from 'react'\nimport type {\n  ComputedColumn,\n  StickyState,\n  BorderConfig,\n  BackgroundConfig,\n  ColumnChange,\n  SelectionState,\n} from '../types'\nimport { getBodyOuterBorders, getBodyOuterBorderStyles } from '../utils'\nimport { TableRow } from './table-row'\nimport { useAutoColumnFlip } from '../hooks'\nimport { TABLE_CONFIG } from '../config'\n\ninterface TableBodyProps<T = Record<string, unknown>> {\n  /** Forwarded scroll container ref */\n  bodyScrollRef: RefObject<HTMLDivElement | null>\n  /** Data array to render */\n  data: T[]\n  /** Sticky columns */\n  stickyColumns: ComputedColumn[]\n  /** Scrollable columns */\n  scrollableColumns: ComputedColumn[]\n  /** All visible columns */\n  allColumns: ComputedColumn[]\n  /** Sticky state for styling */\n  stickyState: StickyState\n  /** Border configuration */\n  borderConfig: BorderConfig\n  /** Background configuration */\n  backgroundConfig: BackgroundConfig\n  /** Border radius */\n  borderRadius: number\n  /** Row height override */\n  rowHeight?: number\n  /** Cell render function */\n  renderCell: (columnKey: string, row: T, index: number) => ReactNode\n  /** Row click handler */\n  onRowClick?: (row: T, index: number) => void\n  /** Column change for animation */\n  columnChange: ColumnChange | null\n  /** Leaving column keys */\n  leavingColumnKeys: Set<string>\n  /** Leaving columns with position data (for absolute overlay) */\n  leavingColumns: ComputedColumn[]\n  /** Entering column keys */\n  enteringColumnKeys: Set<string>\n  /** Selection state */\n  selectionState: SelectionState | null\n  /** Row ID getter */\n  getRowId?: (row: T, index: number) => string | number\n  /** Loading indicator content */\n  loadingIndicator?: ReactNode\n  /** Callback when end reached */\n  onEndReached?: () => void\n  /** Threshold for end reached */\n  onEndReachedThreshold?: number\n  /** Ref to track the last dropped column key for FLIP animation exclusion (shared with header) */\n  lastDroppedKeyRef?: React.RefObject<string | null>\n  // ---- Drag State for inline column shifting ----\n  /** Get shift direction for a column */\n  getShiftDirection?: (columnKey: string, colIndex: number) => 'left' | 'right' | null\n  /** Get inline offset for dragged column */\n  getInlineOffset?: (columnKey: string) => number | null\n  /** Get shift amount in pixels */\n  getShiftAmount?: () => number\n  /** Whether in inline drag mode */\n  isInlineDragMode?: boolean\n  /** Key of the column being dragged */\n  draggedColumnKey?: string | null\n}\n\n/**\n * Table body component\n *\n * Features:\n * - Scrollable container with sync\n * - Memoized row rendering\n * - Sticky cell positioning\n * - Selection checkbox support\n */\nfunction TableBodyBase<T extends Record<string, unknown>>({\n  bodyScrollRef,\n  data,\n  stickyColumns,\n  scrollableColumns,\n  allColumns,\n  stickyState,\n  borderConfig,\n  backgroundConfig,\n  borderRadius,\n  rowHeight = TABLE_CONFIG.ROW_HEIGHT,\n  renderCell,\n  onRowClick,\n  columnChange,\n  leavingColumnKeys,\n  leavingColumns,\n  enteringColumnKeys,\n  selectionState,\n  getRowId,\n  loadingIndicator,\n  onEndReached,\n  onEndReachedThreshold = 200,\n  lastDroppedKeyRef,\n  // Drag state for inline column shifting\n  getShiftDirection,\n  getInlineOffset,\n  getShiftAmount,\n  isInlineDragMode = false,\n  draggedColumnKey,\n}: TableBodyProps<T>) {\n  const outerBorderClasses = getBodyOuterBorders(borderConfig)\n  const outerBorderStyles = getBodyOuterBorderStyles(borderConfig)\n  const sentinelRef = useRef<HTMLDivElement>(null)\n\n  // Auto-FLIP: Smooth column shift animations for body cells\n  const columnKeys = allColumns.map((col) => col.key)\n  useAutoColumnFlip(bodyScrollRef, columnKeys, {\n    draggedKeyRef: lastDroppedKeyRef,\n  })\n\n  // Calculate total sticky width for positioning leaving columns\n  const totalStickyWidth = stickyColumns.reduce((sum, col) => sum + col.width, 0)\n\n  useEffect(() => {\n    if (!onEndReached || !sentinelRef.current) return\n\n    const observer = new IntersectionObserver(\n      (entries) => {\n        if (entries[0]?.isIntersecting) {\n          onEndReached()\n        }\n      },\n      {\n        root: null, // Use viewport as root to support window scrolling\n        rootMargin: `0px 0px ${onEndReachedThreshold}px 0px`,\n      }\n    )\n\n    observer.observe(sentinelRef.current)\n    return () => observer.disconnect()\n  }, [onEndReached, onEndReachedThreshold])\n\n  return (\n    <div className=\"relative\">\n      {/* Main scrollable body */}\n      <div\n        ref={bodyScrollRef}\n        className={`overflow-x-auto overflow-y-hidden ${outerBorderClasses} ${backgroundConfig.bodyContainer}`}\n        style={{\n          scrollbarWidth: 'none',\n          msOverflowStyle: 'none',\n          overscrollBehaviorX: 'none',\n          overscrollBehaviorY: 'none',\n          lineHeight: 0,\n          fontSize: 0,\n          borderBottomLeftRadius: `${borderRadius}px`,\n          borderBottomRightRadius: `${borderRadius}px`,\n          willChange: 'scroll-position',\n          ...outerBorderStyles, // Side-specific border colors\n        }}\n      >\n        {data.map((row, index) => {\n          const rowId = getRowId ? getRowId(row, index) : index\n\n          return (\n            <TableRow\n              key={rowId}\n              row={row}\n              index={index}\n              rowId={rowId}\n              stickyColumns={stickyColumns}\n              scrollableColumns={scrollableColumns}\n              allColumns={allColumns}\n              stickyState={stickyState}\n              borderConfig={borderConfig}\n              backgroundConfig={backgroundConfig}\n              rowHeight={rowHeight}\n              renderCell={renderCell}\n              onRowClick={onRowClick}\n              columnChange={columnChange}\n              leavingColumnKeys={leavingColumnKeys}\n              enteringColumnKeys={enteringColumnKeys}\n              selectionState={selectionState}\n              // Drag state for inline column shifting\n              getShiftDirection={getShiftDirection}\n              getInlineOffset={getInlineOffset}\n              getShiftAmount={getShiftAmount}\n              isInlineDragMode={isInlineDragMode}\n              draggedColumnKey={draggedColumnKey}\n            />\n          )\n        })}\n\n        {/* Sentinel for infinite scroll */}\n        {onEndReached && <div ref={sentinelRef} style={{ height: 1, width: 1, pointerEvents: 'none', opacity: 0 }} />}\n\n        {/* Loading Indicator (injected into scroll container) */}\n        {/* Pass table's columns (with checkbox) and configs to ensure skeleton matches real table */}\n        {loadingIndicator && (\n          <div style={{ minWidth: '100%', width: 'fit-content' }}>\n            {React.isValidElement(loadingIndicator)\n              ? React.cloneElement(loadingIndicator, {\n                  stickyState,\n                  columns: allColumns, // Pass computed columns with checkbox\n                  enableSelection: false, // Columns already include checkbox, don't add again\n                  borderConfig, // Pass table's border config\n                  backgroundConfig, // Pass table's background config\n                  rowHeight, // Pass table's row height\n                } as Partial<unknown>)\n              : loadingIndicator}\n          </div>\n        )}\n      </div>\n\n    </div>\n  )\n}\n\nconst MemoizedTableBody = memo(TableBodyBase)\n// Type assertion to preserve generic type information\nexport const TableBody = MemoizedTableBody as <T extends Record<string, unknown>>(\n  props: TableBodyProps<T>\n) => React.ReactElement\n;(TableBody as any).displayName = 'TableBody'\n\n\n"]}