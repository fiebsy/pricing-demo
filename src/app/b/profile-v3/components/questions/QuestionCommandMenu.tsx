/**
 * QuestionCommandMenu Component
 *
 * Wraps the command-menu-v4 Preview component for profile context.
 * Each question becomes an expandable command menu with inline AI response.
 *
 * @module b/profile-v3/components/questions
 */

'use client'

import * as React from 'react'
import { useCallback, useEffect, useMemo, useRef, useState } from 'react'
import { cn } from '@/lib/utils'
import { V4Provider, useV4Context, Preview } from '@/components/ui/features/question-command-menu'
import type { ChatMessage, QuestionCommandMenuV4Config } from '@/components/ui/features/question-command-menu'
import { PROFILE_COMMAND_CONFIG, PROFILE_FLOW_CONFIG } from '../../config/question-command-config'
import type { ProfileQuestion, CategoryType } from '../../types'

// =============================================================================
// TYPES
// =============================================================================

export interface QuestionCommandMenuProps {
  question: ProfileQuestion
  isExpanded: boolean
  onExpandRequest: () => void
  onCollapse: () => void
  onQuestionUpdate: (question: ProfileQuestion) => void
  onDelete: (question: ProfileQuestion) => void
  onCategoryHighlight?: (category: CategoryType) => void
  className?: string
}

// =============================================================================
// SIMULATED AI RESPONSE
// =============================================================================

const SIMULATED_RESPONSES: Record<string, string> = {
  default: 'Based on your profile data, I can provide a thoughtful response. This would be generated by analyzing your career history, skills, and professional experiences to give a personalized answer.',
}

function generateSimulatedResponse(question: string): string {
  return SIMULATED_RESPONSES.default
}

// =============================================================================
// INNER COMPONENT (uses context)
// =============================================================================

interface InnerQuestionMenuProps {
  question: ProfileQuestion
  isExpanded: boolean
  onExpandRequest: () => void
  onCollapse: () => void
  onQuestionUpdate: (question: ProfileQuestion) => void
  onDelete: (question: ProfileQuestion) => void
  onCategoryHighlight?: (category: CategoryType) => void
}

function InnerQuestionMenu({
  question,
  isExpanded,
  onExpandRequest,
  onCollapse,
  onQuestionUpdate,
  onDelete,
  onCategoryHighlight,
}: InnerQuestionMenuProps) {
  const {
    state,
    flowStateId,
    setInput,
    expand,
    collapse,
    submitQuestion,
    receiveResponse,
    startEditing,
    cancelEditing,
  } = useV4Context()

  const [isProcessing, setIsProcessing] = useState(false)
  const processingTimeoutRef = useRef<NodeJS.Timeout | null>(null)

  // Build chat messages from question data
  const chatMessages: ChatMessage[] = useMemo(() => {
    const messages: ChatMessage[] = []

    // Show the question if we're not in idle state or if we have a response
    if (flowStateId !== 'idle' || question.aiResponse) {
      // User question
      messages.push({
        id: `${question.id}-user`,
        role: 'user',
        content: state.storedQuestion || question.text,
        isStreaming: false,
      })
    }

    // AI response
    if (question.aiResponse && flowStateId !== 'adding') {
      messages.push({
        id: `${question.id}-assistant`,
        role: 'assistant',
        content: question.aiResponse,
        isStreaming: flowStateId === 'processing',
        confidence: question.aiConfidence ?? undefined,
      })
    }

    return messages
  }, [question, flowStateId, state.storedQuestion])

  // Sync expansion state with coordinator
  useEffect(() => {
    if (isExpanded && !state.expanded) {
      expand()
    } else if (!isExpanded && state.expanded) {
      collapse()
    }
  }, [isExpanded, state.expanded, expand, collapse])

  // Initialize input value with question text
  useEffect(() => {
    if (!state.inputValue && question.text) {
      setInput(question.text)
    }
  }, [question.text, state.inputValue, setInput])

  // Highlight category on expand
  useEffect(() => {
    if (isExpanded && onCategoryHighlight) {
      onCategoryHighlight(question.linkedCategory)
    }
  }, [isExpanded, question.linkedCategory, onCategoryHighlight])

  // Handle chat send (submit question to AI)
  const handleChatSend = useCallback(
    (message: string) => {
      // Update question text if changed
      if (message !== question.text) {
        onQuestionUpdate({
          ...question,
          text: message,
        })
      }

      // Start processing
      setIsProcessing(true)
      submitQuestion(question.aiConfidence ?? 0.85)

      // Simulate AI response after delay
      processingTimeoutRef.current = setTimeout(() => {
        const response = question.aiResponse || generateSimulatedResponse(message)
        receiveResponse(response)
        setIsProcessing(false)

        // Update question with response
        onQuestionUpdate({
          ...question,
          text: message,
          aiResponse: response,
          aiConfidence: 0.85,
        })
      }, 1500)
    },
    [question, onQuestionUpdate, submitQuestion, receiveResponse]
  )

  // Handle regenerate
  const handleChatRegenerate = useCallback(
    (messageId: string) => {
      setIsProcessing(true)
      submitQuestion(question.aiConfidence ?? 0.85)

      processingTimeoutRef.current = setTimeout(() => {
        const newResponse = generateSimulatedResponse(question.text)
        receiveResponse(newResponse)
        setIsProcessing(false)

        onQuestionUpdate({
          ...question,
          aiResponse: newResponse,
          aiConfidence: 0.88,
        })
      }, 1500)
    },
    [question, onQuestionUpdate, submitQuestion, receiveResponse]
  )

  // Handle delete
  const handleDelete = useCallback(() => {
    onDelete(question)
    collapse()
    onCollapse()
  }, [question, onDelete, collapse, onCollapse])

  // Handle question save
  const handleQuestionSave = useCallback(
    (newQuestion: string) => {
      onQuestionUpdate({
        ...question,
        text: newQuestion,
      })
    },
    [question, onQuestionUpdate]
  )

  // Cleanup timeout on unmount
  useEffect(() => {
    return () => {
      if (processingTimeoutRef.current) {
        clearTimeout(processingTimeoutRef.current)
      }
    }
  }, [])

  return (
    <Preview
      config={PROFILE_COMMAND_CONFIG}
      chatMessages={chatMessages}
      isChatTyping={isProcessing}
      onChatSend={handleChatSend}
      onChatRegenerate={handleChatRegenerate}
      onQuestionSave={handleQuestionSave}
      onDelete={handleDelete}
      skipProvider // We're already in V4Provider
    />
  )
}

// =============================================================================
// MAIN COMPONENT
// =============================================================================

export function QuestionCommandMenu({
  question,
  isExpanded,
  onExpandRequest,
  onCollapse,
  onQuestionUpdate,
  onDelete,
  onCategoryHighlight,
  className,
}: QuestionCommandMenuProps) {
  // Determine initial flow state based on question data
  const hasResponse = Boolean(question.aiResponse)

  // Build config with question-specific state
  const config: QuestionCommandMenuV4Config = useMemo(
    () => ({
      ...PROFILE_COMMAND_CONFIG,
      flowConfigs: PROFILE_FLOW_CONFIG,
    }),
    []
  )

  // Handle click on collapsed trigger
  const handleClick = useCallback(() => {
    if (!isExpanded) {
      onExpandRequest()
    }
  }, [isExpanded, onExpandRequest])

  return (
    <div
      className={cn(
        'relative',
        'motion-safe:transition-all motion-safe:duration-200',
        'motion-reduce:transition-none',
        className
      )}
      onClick={!isExpanded ? handleClick : undefined}
    >
      <V4Provider
        config={config}
        initialMode="input"
      >
        <InnerQuestionMenu
          question={question}
          isExpanded={isExpanded}
          onExpandRequest={onExpandRequest}
          onCollapse={onCollapse}
          onQuestionUpdate={onQuestionUpdate}
          onDelete={onDelete}
          onCategoryHighlight={onCategoryHighlight}
        />
      </V4Provider>
    </div>
  )
}

QuestionCommandMenu.displayName = 'QuestionCommandMenu'
